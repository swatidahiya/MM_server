import { __decorate } from 'tslib';
import { Input, Directive, forwardRef, NgModule } from '@angular/core';
import { Validators, NG_VALIDATORS } from '@angular/forms';
import { delay } from 'rxjs/operators';

class AbstractControlUtil {
    static isNotPresent(control) {
        const value = control.value;
        if (value === undefined || value === null) {
            return true;
        }
        return value !== "" ? false : true;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static addError(control, errorId, value) {
        if (!control.errors) {
            control.setErrors({ [errorId]: value });
        }
        else if (!control.hasError(errorId)) {
            control.errors[errorId] = value;
        }
    }
    static removeError(control, errorId) {
        if (control.errors && control.hasError(errorId)) {
            if (Object.keys(control.errors).length > 1) {
                delete control.errors[errorId];
            }
            else {
                control.setErrors(null);
            }
        }
    }
}

// tslint:disable-next-line:variable-name
class PasswordValidators {
    static repeatCharacterRegexRule(repeatCount) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const repeatDec = repeatCount - 1;
            const pattern = "([^\\x00-\\x1F])\\1{" + repeatDec + "}";
            if (control.value !== "" && new RegExp(pattern).test(control.value)) {
                return { repeatCharacterRegexRule: { repeatCount } };
            }
            return undefined;
        };
        return validator;
    }
    static allowedCharacterRule(allowedChars) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            let valid = true;
            const invalidChars = [];
            for (const char of value) {
                if (allowedChars.indexOf(char) === -1) {
                    valid = false;
                    if (invalidChars.indexOf(char) === -1) {
                        invalidChars.push(char);
                    }
                }
            }
            if (!valid) {
                return {
                    allowedCharacterRule: {
                        invalidChars,
                        allowedChars,
                    },
                };
            }
            return undefined;
        };
        return validator;
    }
    static alphabeticalCharacterRule(amount) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            const pattern = /[^A-Za-z]+/g;
            const stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    alphabeticalCharacterRule: {
                        required: amount,
                        actual: stripped.length,
                    },
                };
            }
            return undefined;
        };
        return validator;
    }
    static digitCharacterRule(amount) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            const pattern = /[^0-9\.]+/g;
            const stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    digitCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    }
    static lowercaseCharacterRule(amount) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            const pattern = /[^a-z]+/g;
            const stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    lowercaseCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    }
    static uppercaseCharacterRule(amount) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            const pattern = /[^A-Z]+/g;
            const stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    uppercaseCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    }
    static specialCharacterRule(amount) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            const pattern = /[\w\s]+/g;
            const stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    specialCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    }
    static mismatchedPasswords(passwordControlName, confirmPasswordControlName) {
        const validator = (group) => {
            const newPasswordValue = group.get(passwordControlName ? passwordControlName : "newPassword").value;
            const newPasswordConfirmValue = group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword").value;
            if (newPasswordValue !== newPasswordConfirmValue) {
                AbstractControlUtil.addError(group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword"), "mismatchedPasswords", true);
                return { mismatchedPasswords: true };
            }
            else {
                AbstractControlUtil.removeError(group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword"), "mismatchedPasswords");
            }
            return undefined;
        };
        return validator;
    }
}

/*
 * Code fromMailcheck https://github.com/mailcheck/mailcheck
 * Author
 * Derrick Ko (@derrickko)
 *
 * Released under the MIT License.
 *
 * v 1.1.2
 */
class EmailSuggestion {
    constructor() {
        this.defaultOptions = {
            domains: [
                "msn.com",
                "bellsouth.net",
                "telus.net",
                "comcast.net",
                "optusnet.com.au",
                "earthlink.net",
                "qq.com",
                "sky.com",
                "icloud.com",
                "mac.com",
                "sympatico.ca",
                "googlemail.com",
                "att.net",
                "xtra.co.nz",
                "web.de",
                "cox.net",
                "gmail.com",
                "ymail.com",
                "yahoo.com",
                "aim.com",
                "rogers.com",
                "verizon.net",
                "rocketmail.com",
                "google.com",
                "optonline.net",
                "sbcglobal.net",
                "aol.com",
                "me.com",
                "btinternet.com",
                "charter.net",
                "shaw.ca",
            ],
            secondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],
            topLevelDomains: [
                "com",
                "com.au",
                "com.tw",
                "ca",
                "co.nz",
                "co.uk",
                "de",
                "fr",
                "it",
                "ru",
                "net",
                "org",
                "edu",
                "gov",
                "jp",
                "nl",
                "kr",
                "se",
                "eu",
                "ie",
                "co.il",
                "us",
                "at",
                "be",
                "dk",
                "hk",
                "es",
                "gr",
                "ch",
                "no",
                "cz",
                "in",
                "net",
                "net.au",
                "info",
                "biz",
                "mil",
                "co.jp",
                "sg",
                "hu",
                "uk",
            ],
        };
    }
    suggest(email, options) {
        let opt = this.defaultOptions;
        if (options !== undefined) {
            opt = options;
        }
        const emailParts = this.splitEmail(email.toLowerCase());
        if (!emailParts) {
            return undefined;
        }
        if (opt.secondLevelDomains && opt.topLevelDomains) {
            // If the email is a valid 2nd-level + top-level, do not suggest anything.
            if (opt.secondLevelDomains.indexOf(emailParts.secondLevelDomain) !== -1 &&
                opt.topLevelDomains.indexOf(emailParts.topLevelDomain) !== -1) {
                return undefined;
            }
        }
        let closestDomain = this.findClosestDomain(emailParts.domain, opt.domains, 2);
        if (closestDomain) {
            if (closestDomain === emailParts.domain) {
                // The email address exactly matches one of the supplied domains; do not return a suggestion.
                return undefined;
            }
            else {
                // The email address closely matches one of the supplied domains; return a suggestion
                return {
                    suggestion: {
                        address: emailParts.address,
                        domain: closestDomain,
                        full: emailParts.address + "@" + closestDomain,
                    },
                };
            }
        }
        const closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, opt.secondLevelDomains, 2);
        const closestTopLevelDomain = this.findClosestDomain(emailParts.topLevelDomain, opt.topLevelDomains, 2);
        if (emailParts.domain) {
            closestDomain = emailParts.domain;
            let rtrn = false;
            if (closestSecondLevelDomain && closestSecondLevelDomain !== emailParts.secondLevelDomain) {
                // The email address may have a mispelled second-level domain; return a suggestion
                closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain);
                rtrn = true;
            }
            if (closestTopLevelDomain &&
                closestTopLevelDomain !== emailParts.topLevelDomain &&
                emailParts.secondLevelDomain !== "") {
                // The email address may have a mispelled top-level domain; return a suggestion
                closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain);
                rtrn = true;
            }
            if (rtrn) {
                return {
                    suggestion: {
                        address: emailParts.address,
                        domain: closestDomain,
                        full: emailParts.address + "@" + closestDomain,
                    },
                };
            }
        }
        /* The email address exactly matches one of the supplied domains, does not closely
         * match any domain and does not appear to simply have a mispelled top-level domain,
         * or is an invalid email address; do not return a suggestion.
         */
        return undefined;
    }
    splitEmail(email) {
        const parts = email.trim().split("@");
        if (parts.length < 2) {
            return undefined;
        }
        // tslint:disable-next-line: prefer-for-of
        for (let i = 0; i < parts.length; i++) {
            if (parts[i] === "") {
                return undefined;
            }
        }
        const result = {
            topLevelDomain: "",
            secondLevelDomain: "",
            domain: parts.pop(),
            address: "",
        };
        const domainParts = result.domain.split(".");
        if (domainParts.length === 0) {
            return undefined;
        }
        else if (domainParts.length === 1) {
            result.topLevelDomain = domainParts[0];
        }
        else {
            // The address has a domain and a top-level domain
            result.secondLevelDomain = domainParts[0];
            for (let j = 1; j < domainParts.length; j++) {
                result.topLevelDomain += domainParts[j] + ".";
            }
            result.topLevelDomain = result.topLevelDomain.substring(0, result.topLevelDomain.length - 1);
        }
        result.address = parts.join("@");
        return result;
    }
    findClosestDomain(domain, domains, threshold) {
        let dist;
        let minDist = Infinity;
        let closestDomain = null;
        if (!domain || !domains) {
            return undefined;
        }
        // tslint:disable-next-line: prefer-for-of
        for (let i = 0; i < domains.length; i++) {
            if (domain === domains[i]) {
                return domain;
            }
            dist = this.sift4Distance(domain, domains[i], 5);
            if (dist < minDist) {
                minDist = dist;
                closestDomain = domains[i];
            }
        }
        if (minDist <= threshold && closestDomain !== null) {
            return closestDomain;
        }
        else {
            return undefined;
        }
    }
    sift4Distance(s1, s2, maxOffset) {
        // sift4: https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
        if (maxOffset === undefined) {
            maxOffset = 5; // default
        }
        if (!s1 || !s1.length) {
            if (!s2) {
                return 0;
            }
            return s2.length;
        }
        if (!s2 || !s2.length) {
            return s1.length;
        }
        const l1 = s1.length;
        const l2 = s2.length;
        let c1 = 0; // cursor for string 1
        let c2 = 0; // cursor for string 2
        let lcss = 0; // largest common subsequence
        let localCS = 0; // local common substring
        let trans = 0; // number of transpositions ('ab' vs 'ba')
        const offsetArr = []; // offset pair array, for computing the transpositions
        while (c1 < l1 && c2 < l2) {
            if (s1.charAt(c1) === s2.charAt(c2)) {
                localCS++;
                let isTrans = false;
                // see if current match is a transposition
                let i = 0;
                while (i < offsetArr.length) {
                    const ofs = offsetArr[i];
                    if (c1 <= ofs.c1 || c2 <= ofs.c2) {
                        // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                        isTrans = Math.abs(c2 - c1) >= Math.abs(ofs.c2 - ofs.c1);
                        if (isTrans) {
                            trans++;
                        }
                        else {
                            if (!ofs.trans) {
                                ofs.trans = true;
                                trans++;
                            }
                        }
                        break;
                    }
                    else {
                        if (c1 > ofs.c2 && c2 > ofs.c1) {
                            offsetArr.splice(i, 1);
                        }
                        else {
                            i++;
                        }
                    }
                }
                offsetArr.push({
                    c1,
                    c2,
                    trans: isTrans,
                });
            }
            else {
                lcss += localCS;
                localCS = 0;
                if (c1 !== c2) {
                    c1 = c2 = Math.min(c1, c2); // using min allows the computation of transpositions
                }
                // if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
                // so that we can have only one code block handling matches
                for (let j = 0; j < maxOffset && (c1 + j < l1 || c2 + j < l2); j++) {
                    if (c1 + j < l1 && s1.charAt(c1 + j) === s2.charAt(c2)) {
                        c1 += j - 1;
                        c2--;
                        break;
                    }
                    if (c2 + j < l2 && s1.charAt(c1) === s2.charAt(c2 + j)) {
                        c1--;
                        c2 += j - 1;
                        break;
                    }
                }
            }
            c1++;
            c2++;
            // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
            if (c1 >= l1 || c2 >= l2) {
                lcss += localCS;
                localCS = 0;
                c1 = c2 = Math.min(c1, c2);
            }
        }
        lcss += localCS;
        return Math.round(Math.max(l1, l2) - lcss + trans); // add the cost of transpositions to the final result
    }
}

class EmailValidators {
    static simple(control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        const pattern = /.+@.+\..+/i;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { simpleEmailRule: true };
    }
    // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    static normal(control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        // tslint:disable-next-line:max-line-length
        const pattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { normalEmailRule: true };
    }
    static suggest(options) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control)) {
                return undefined;
            }
            return this.emailSuggestion.suggest(control.value, options);
        };
        return validator;
    }
}
EmailValidators.emailSuggestion = new EmailSuggestion();

class UniversalValidators {
    static noWhitespace(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        const pattern = "\\s";
        if (new RegExp(pattern).test(control.value)) {
            return { noWhitespaceRequired: true };
        }
        return undefined;
    }
    static noEmptyString(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (control.value.trim().length === 0) {
            return { noEmptyString: true };
        }
        return undefined;
    }
    static isNumber(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (isNaN(control.value)) {
            return { numberRequired: true };
        }
        return undefined;
    }
    static isInRange(minValue, maxValue) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            if (+control.value < minValue) {
                return {
                    rangeValueToSmall: {
                        requiredMinValue: minValue,
                        requiredMaxValue: maxValue,
                        actual: control.value,
                    },
                };
            }
            if (+control.value > maxValue) {
                return {
                    rangeValueToBig: {
                        requiredMinValue: minValue,
                        requiredMaxValue: maxValue,
                        actual: control.value,
                    },
                };
            }
            else {
                return undefined;
            }
        };
        return validator;
    }
    static minLength(minLength) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (value.length >= minLength) {
                return undefined;
            }
            return {
                minLength: { requiredMinLength: minLength, actualLength: value.length },
            };
        };
        return validator;
    }
    static maxLength(maxLength) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (maxLength >= value.length) {
                return undefined;
            }
            return {
                maxLength: { requiredMaxLength: maxLength, actualLength: value.length },
            };
        };
        return validator;
    }
    static min(min) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            if (+value >= min) {
                return undefined;
            }
            return { min: { required: min, actual: control.value } };
        };
        return validator;
    }
    static max(max) {
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            const value = control.value;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            if (max >= +value) {
                return undefined;
            }
            return { max: { required: max, actual: control.value } };
        };
        return validator;
    }
}

const visaRegex = "^(?:4[0-9]{12})(?:[0-9]{3})?$";
const americanExpressRegex = "^(?:3[47][0-9]{13})$";
const maestroRegex = "^(?:(?:5[0678]\\d\\d|6304|6390|67\\d\\d)\\d{8,15})$";
const jcbRegex = "^(?:(?:2131|1800|35\\d{3})\\d{11})$";
const discoverRegex = "^(?:6(?:011|5[0-9]{2})(?:[0-9]{12}))$";
const dinersclubRegex = "^(?:3(?:0[0-5]|[68][0-9])[0-9]{11})$";
const mastercardRegex = "^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$";
class CreditCardValidators {
    static isCreditCard(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex +
            "|" +
            visaRegex +
            "|" +
            maestroRegex +
            "|" +
            jcbRegex +
            "|" +
            discoverRegex +
            "|" +
            mastercardRegex +
            "|" +
            dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { creditcard: true };
    }
    static americanExpress(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex).test(control.value)) {
            return undefined;
        }
        return { americanExpress: true };
    }
    static dinersclub(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { dinersclub: true };
    }
    static discover(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(discoverRegex).test(control.value)) {
            return undefined;
        }
        return { discover: true };
    }
    static jcb(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(jcbRegex).test(control.value)) {
            return undefined;
        }
        return { jcb: true };
    }
    static maestro(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(maestroRegex).test(control.value)) {
            return undefined;
        }
        return { maestro: true };
    }
    static mastercard(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(mastercardRegex).test(control.value)) {
            return undefined;
        }
        return { mastercard: true };
    }
    static visa(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(visaRegex).test(control.value)) {
            return undefined;
        }
        return { visa: true };
    }
}

var PasswordValidatorDirective_1;
let PasswordValidatorDirective = PasswordValidatorDirective_1 = class PasswordValidatorDirective {
    constructor() {
        this.repeatCharacter = 4;
        this.alphabeticalCharacter = 1;
        this.digitCharacter = 1;
        this.lowercaseCharacter = 1;
        this.uppercaseCharacter = 1;
    }
    ngOnInit() {
        this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(this.repeatCharacter);
        this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(this.alphabeticalCharacter);
        this.digitCharacterValidator = PasswordValidators.digitCharacterRule(this.digitCharacter);
        this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(this.lowercaseCharacter);
        this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(this.uppercaseCharacter);
    }
    ngOnChanges(changes) {
        let inputChanged = false;
        if (changes.repeatCharacter) {
            this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(changes.repeatCharacter.currentValue);
            inputChanged = changes.repeatCharacter.isFirstChange() ? false : true;
        }
        if (changes.alphabeticalCharacter) {
            this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(changes.alphabeticalCharacter.currentValue);
            inputChanged = changes.alphabeticalCharacter.isFirstChange() ? false : true;
        }
        if (changes.digitCharacter) {
            this.digitCharacterValidator = PasswordValidators.digitCharacterRule(changes.digitCharacter.currentValue);
            inputChanged = changes.digitCharacter.isFirstChange() ? false : true;
        }
        if (changes.lowercaseCharacter) {
            this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(changes.lowercaseCharacter.currentValue);
            inputChanged = changes.lowercaseCharacter.isFirstChange() ? false : true;
        }
        if (changes.uppercaseCharacter) {
            this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(changes.uppercaseCharacter.currentValue);
            inputChanged = changes.uppercaseCharacter.isFirstChange() ? false : true;
        }
        if (inputChanged) {
            this.onChange();
        }
    }
    validate(c) {
        const compose = Validators.compose([
            this.repeatCharacterValidator,
            this.digitCharacterValidator,
            this.alphabeticalCharacterValidator,
            this.lowercaseCharacterValidator,
            this.uppercaseCharacterValidator,
        ]);
        return compose(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input()
], PasswordValidatorDirective.prototype, "repeatCharacter", void 0);
__decorate([
    Input()
], PasswordValidatorDirective.prototype, "alphabeticalCharacter", void 0);
__decorate([
    Input()
], PasswordValidatorDirective.prototype, "digitCharacter", void 0);
__decorate([
    Input()
], PasswordValidatorDirective.prototype, "lowercaseCharacter", void 0);
__decorate([
    Input()
], PasswordValidatorDirective.prototype, "uppercaseCharacter", void 0);
PasswordValidatorDirective = PasswordValidatorDirective_1 = __decorate([
    Directive({
        selector: "[password][formControlName],[password][formControl],[password][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => PasswordValidatorDirective_1),
                multi: true,
            },
        ],
    })
], PasswordValidatorDirective);

var EmailValidatorDirective_1, EmailSuggestValidatorDirective_1;
let EmailValidatorDirective = EmailValidatorDirective_1 = class EmailValidatorDirective {
    constructor() {
        this.email = "normal";
    }
    ngOnInit() {
        this.setValidator(this.email);
    }
    setValidator(type) {
        switch (type) {
            case "simple":
                this.validator = EmailValidators.simple;
                break;
            case "normal":
                this.validator = EmailValidators.normal;
                break;
            default:
                this.validator = EmailValidators.normal;
                break;
        }
    }
    ngOnChanges(changes) {
        if (changes.email && !changes.email.isFirstChange()) {
            this.setValidator(changes.email.currentValue);
            this.onChange();
        }
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    validate(c) {
        return this.validator(c);
    }
};
__decorate([
    Input()
], EmailValidatorDirective.prototype, "email", void 0);
EmailValidatorDirective = EmailValidatorDirective_1 = __decorate([
    Directive({
        selector: "[email][formControlName],[email][formControl],[email][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => EmailValidatorDirective_1),
                multi: true,
            },
        ],
    })
], EmailValidatorDirective);
let EmailSuggestValidatorDirective = EmailSuggestValidatorDirective_1 = class EmailSuggestValidatorDirective {
    ngOnInit() {
        this.validator = EmailValidators.suggest(this.emailSuggest);
    }
    ngOnChanges(changes) {
        if (changes.emailSuggest && !changes.emailSuggest.isFirstChange()) {
            this.validator = EmailValidators.suggest(changes.emailSuggest.currentValue);
            this.onChange();
        }
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    validate(c) {
        return this.validator(c);
    }
};
__decorate([
    Input()
], EmailSuggestValidatorDirective.prototype, "emailSuggest", void 0);
EmailSuggestValidatorDirective = EmailSuggestValidatorDirective_1 = __decorate([
    Directive({
        selector: "[emailSuggest][formControlName],[emailSuggest][formControl],[emailSuggest][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => EmailSuggestValidatorDirective_1),
                multi: true,
            },
        ],
    })
], EmailSuggestValidatorDirective);

var WhiteSpaceValidatorDirective_1, EmptyStringValidatorDirective_1, IsNumberValidatorDirective_1, IsInRangeValidatorDirective_1, MaxValidatorDirective_1, MinValidatorDirective_1;
let WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = class WhiteSpaceValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.noWhitespace;
    }
    validate(c) {
        return this.validator(c);
    }
};
WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = __decorate([
    Directive({
        selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => WhiteSpaceValidatorDirective_1),
                multi: true,
            },
        ],
    })
], WhiteSpaceValidatorDirective);
let EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = class EmptyStringValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.noEmptyString;
    }
    validate(c) {
        return this.validator(c);
    }
};
EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = __decorate([
    Directive({
        selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => EmptyStringValidatorDirective_1),
                multi: true,
            },
        ],
    })
], EmptyStringValidatorDirective);
let IsNumberValidatorDirective = IsNumberValidatorDirective_1 = class IsNumberValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.isNumber;
    }
    validate(c) {
        return this.validator(c);
    }
};
IsNumberValidatorDirective = IsNumberValidatorDirective_1 = __decorate([
    Directive({
        selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => IsNumberValidatorDirective_1),
                multi: true,
            },
        ],
    })
], IsNumberValidatorDirective);
let IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = class IsInRangeValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    }
    ngOnChanges(changes) {
        let minValue = this.minValue;
        let maxValue = this.maxValue;
        let changed = false;
        if (changes.minValue) {
            minValue = changes.minValue.currentValue;
            changed = changes.minValue.isFirstChange() ? false : true;
        }
        if (changes.maxValue) {
            maxValue = changes.maxValue.currentValue;
            changed = changes.maxValue.isFirstChange() ? false : true;
        }
        if (changed) {
            this.validator = UniversalValidators.isInRange(minValue, maxValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input()
], IsInRangeValidatorDirective.prototype, "minValue", void 0);
__decorate([
    Input()
], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = __decorate([
    Directive({
        selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => IsInRangeValidatorDirective_1),
                multi: true,
            },
        ],
    })
], IsInRangeValidatorDirective);
let MaxValidatorDirective = MaxValidatorDirective_1 = class MaxValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.max(this.max);
    }
    ngOnChanges(changes) {
        if (changes.max && !changes.max.isFirstChange()) {
            this.validator = UniversalValidators.max(changes.max.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input()
], MaxValidatorDirective.prototype, "max", void 0);
MaxValidatorDirective = MaxValidatorDirective_1 = __decorate([
    Directive({
        selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MaxValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MaxValidatorDirective);
let MinValidatorDirective = MinValidatorDirective_1 = class MinValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.min(this.min);
    }
    ngOnChanges(changes) {
        if (changes.min && !changes.min.isFirstChange()) {
            this.validator = UniversalValidators.min(changes.min.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input()
], MinValidatorDirective.prototype, "min", void 0);
MinValidatorDirective = MinValidatorDirective_1 = __decorate([
    Directive({
        selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MinValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MinValidatorDirective);

var CreditCardValidatorDirective_1;
let CreditCardValidatorDirective = CreditCardValidatorDirective_1 = class CreditCardValidatorDirective {
    constructor() {
        this.creditCard = "all";
    }
    ngOnInit() {
        this.setCreditcardValidator(this.creditCard);
    }
    setCreditcardValidator(type) {
        switch (type) {
            case "all":
                this.validator = CreditCardValidators.isCreditCard;
                break;
            case "americanExpress":
                this.validator = CreditCardValidators.americanExpress;
                break;
            case "dinersclub":
                this.validator = CreditCardValidators.dinersclub;
                break;
            case "discover":
                this.validator = CreditCardValidators.discover;
                break;
            case "jcb":
                this.validator = CreditCardValidators.jcb;
                break;
            case "maestro":
                this.validator = CreditCardValidators.maestro;
                break;
            case "mastercard":
                this.validator = CreditCardValidators.mastercard;
                break;
            case "visa":
                this.validator = CreditCardValidators.visa;
                break;
            default:
                this.validator = CreditCardValidators.isCreditCard;
                break;
        }
    }
    ngOnChanges(changes) {
        if (changes.creditCard && !changes.creditCard.isFirstChange()) {
            this.setCreditcardValidator(changes.creditCard.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input()
], CreditCardValidatorDirective.prototype, "creditCard", void 0);
CreditCardValidatorDirective = CreditCardValidatorDirective_1 = __decorate([
    Directive({
        selector: "[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                useExisting: forwardRef(() => CreditCardValidatorDirective_1),
                multi: true,
            },
        ],
    })
], CreditCardValidatorDirective);

var EqualToDirective_1;
let EqualToDirective = EqualToDirective_1 = class EqualToDirective {
    validate(c) {
        const otherControl = typeof this.equalTo === "string" ? c.parent.get(this.equalTo) : this.equalTo;
        if (!this.subscription) {
            this.subscription = otherControl.valueChanges.pipe(delay(1)).subscribe(() => {
                c.updateValueAndValidity();
            });
        }
        return c.value !== otherControl.value ? { notEqualTo: true } : null;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    ngOnChanges(changes) {
        if (changes.equalTo && !changes.equalTo.isFirstChange()) {
            this.onChange();
        }
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
__decorate([
    Input()
], EqualToDirective.prototype, "equalTo", void 0);
EqualToDirective = EqualToDirective_1 = __decorate([
    Directive({
        selector: "[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => EqualToDirective_1),
                multi: true,
            },
        ],
    })
], EqualToDirective);

let ValidatorsModule = class ValidatorsModule {
};
ValidatorsModule = __decorate([
    NgModule({
        declarations: [
            CreditCardValidatorDirective,
            EmailValidatorDirective,
            EmailSuggestValidatorDirective,
            PasswordValidatorDirective,
            IsInRangeValidatorDirective,
            IsNumberValidatorDirective,
            MaxValidatorDirective,
            MinValidatorDirective,
            WhiteSpaceValidatorDirective,
            EmptyStringValidatorDirective,
            EqualToDirective,
        ],
        exports: [
            CreditCardValidatorDirective,
            EmailValidatorDirective,
            EmailSuggestValidatorDirective,
            PasswordValidatorDirective,
            IsInRangeValidatorDirective,
            IsNumberValidatorDirective,
            MaxValidatorDirective,
            MinValidatorDirective,
            WhiteSpaceValidatorDirective,
            EmptyStringValidatorDirective,
            EqualToDirective,
        ],
    })
], ValidatorsModule);

class EqualToValidator {
    static equalTo(c1Name, c2Name) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const validator = (parent) => {
            const c1 = parent.get(c1Name);
            const c2 = parent.get(c2Name);
            if (c1.value === c2.value) {
                AbstractControlUtil.removeError(c2, "notEqualTo");
            }
            else {
                AbstractControlUtil.addError(c2, "notEqualTo", true);
            }
        };
        return validator;
    }
}

// validators

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractControlUtil, CreditCardValidatorDirective, CreditCardValidators, EmailSuggestValidatorDirective, EmailSuggestion, EmailValidatorDirective, EmailValidators, EmptyStringValidatorDirective, EqualToDirective, EqualToValidator, IsInRangeValidatorDirective, IsNumberValidatorDirective, MaxValidatorDirective, MinValidatorDirective, PasswordValidatorDirective, PasswordValidators, UniversalValidators, ValidatorsModule, WhiteSpaceValidatorDirective };
//# sourceMappingURL=ngx-validators.js.map

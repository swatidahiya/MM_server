import * as tslib_1 from "tslib";
import { Directive, forwardRef, Input } from "@angular/core";
import { NG_VALIDATORS } from "@angular/forms";
import { UniversalValidators } from "./universal-validators";
var WhiteSpaceValidatorDirective = /** @class */ (function () {
    function WhiteSpaceValidatorDirective() {
    }
    WhiteSpaceValidatorDirective_1 = WhiteSpaceValidatorDirective;
    WhiteSpaceValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.noWhitespace;
    };
    WhiteSpaceValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var WhiteSpaceValidatorDirective_1;
    WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return WhiteSpaceValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], WhiteSpaceValidatorDirective);
    return WhiteSpaceValidatorDirective;
}());
export { WhiteSpaceValidatorDirective };
var EmptyStringValidatorDirective = /** @class */ (function () {
    function EmptyStringValidatorDirective() {
    }
    EmptyStringValidatorDirective_1 = EmptyStringValidatorDirective;
    EmptyStringValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.noEmptyString;
    };
    EmptyStringValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var EmptyStringValidatorDirective_1;
    EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EmptyStringValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EmptyStringValidatorDirective);
    return EmptyStringValidatorDirective;
}());
export { EmptyStringValidatorDirective };
var IsNumberValidatorDirective = /** @class */ (function () {
    function IsNumberValidatorDirective() {
    }
    IsNumberValidatorDirective_1 = IsNumberValidatorDirective;
    IsNumberValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.isNumber;
    };
    IsNumberValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var IsNumberValidatorDirective_1;
    IsNumberValidatorDirective = IsNumberValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return IsNumberValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], IsNumberValidatorDirective);
    return IsNumberValidatorDirective;
}());
export { IsNumberValidatorDirective };
var IsInRangeValidatorDirective = /** @class */ (function () {
    function IsInRangeValidatorDirective() {
    }
    IsInRangeValidatorDirective_1 = IsInRangeValidatorDirective;
    IsInRangeValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    };
    IsInRangeValidatorDirective.prototype.ngOnChanges = function (changes) {
        var minValue = this.minValue;
        var maxValue = this.maxValue;
        var changed = false;
        if (changes.minValue) {
            minValue = changes.minValue.currentValue;
            changed = changes.minValue.isFirstChange() ? false : true;
        }
        if (changes.maxValue) {
            maxValue = changes.maxValue.currentValue;
            changed = changes.maxValue.isFirstChange() ? false : true;
        }
        if (changed) {
            this.validator = UniversalValidators.isInRange(minValue, maxValue);
            this.onChange();
        }
    };
    IsInRangeValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    IsInRangeValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var IsInRangeValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], IsInRangeValidatorDirective.prototype, "minValue", void 0);
    tslib_1.__decorate([
        Input()
    ], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
    IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return IsInRangeValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], IsInRangeValidatorDirective);
    return IsInRangeValidatorDirective;
}());
export { IsInRangeValidatorDirective };
var MaxValidatorDirective = /** @class */ (function () {
    function MaxValidatorDirective() {
    }
    MaxValidatorDirective_1 = MaxValidatorDirective;
    MaxValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.max(this.max);
    };
    MaxValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.max && !changes.max.isFirstChange()) {
            this.validator = UniversalValidators.max(changes.max.currentValue);
            this.onChange();
        }
    };
    MaxValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MaxValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MaxValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], MaxValidatorDirective.prototype, "max", void 0);
    MaxValidatorDirective = MaxValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MaxValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MaxValidatorDirective);
    return MaxValidatorDirective;
}());
export { MaxValidatorDirective };
var MinValidatorDirective = /** @class */ (function () {
    function MinValidatorDirective() {
    }
    MinValidatorDirective_1 = MinValidatorDirective;
    MinValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.min(this.min);
    };
    MinValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.min && !changes.min.isFirstChange()) {
            this.validator = UniversalValidators.min(changes.min.currentValue);
            this.onChange();
        }
    };
    MinValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MinValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MinValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], MinValidatorDirective.prototype, "min", void 0);
    MinValidatorDirective = MinValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MinValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MinValidatorDirective);
    return MinValidatorDirective;
}());
export { MinValidatorDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdmVyc2FsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC12YWxpZGF0b3JzLyIsInNvdXJjZXMiOlsiY29tcG9uZW50cy91bml2ZXJzYWwvdW5pdmVyc2FsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFvQyxNQUFNLGVBQWUsQ0FBQztBQUMvRixPQUFPLEVBQW1CLGFBQWEsRUFBNEMsTUFBTSxnQkFBZ0IsQ0FBQztBQUUxRyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQWE3RDtJQUFBO0lBVUEsQ0FBQztxQ0FWWSw0QkFBNEI7SUFHdkMsK0NBQVEsR0FBUjtRQUNFLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsWUFBWSxDQUFDO0lBQ3BELENBQUM7SUFFRCwrQ0FBUSxHQUFSLFVBQVMsQ0FBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0lBVFUsNEJBQTRCO1FBWHhDLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxxRkFBcUY7WUFDL0YsU0FBUyxFQUFFO2dCQUNUO29CQUNFLE9BQU8sRUFBRSxhQUFhO29CQUN0QiwwQ0FBMEM7b0JBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBTSxPQUFBLDhCQUE0QixFQUE1QixDQUE0QixDQUFDO29CQUMzRCxLQUFLLEVBQUUsSUFBSTtpQkFDWjthQUNGO1NBQ0YsQ0FBQztPQUNXLDRCQUE0QixDQVV4QztJQUFELG1DQUFDO0NBQUEsQUFWRCxJQVVDO1NBVlksNEJBQTRCO0FBdUJ6QztJQUFBO0lBVUEsQ0FBQztzQ0FWWSw2QkFBNkI7SUFHeEMsZ0RBQVEsR0FBUjtRQUNFLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsYUFBYSxDQUFDO0lBQ3JELENBQUM7SUFFRCxnREFBUSxHQUFS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QXJCLENBQXFCLENBQUM7b0JBQ3BELEtBQUssRUFBRSxJQUFJO2lCQUNaO2FBQ0Y7U0FDRixDQUFDO09BQ1cscUJBQXFCLENBd0JqQztJQUFELDRCQUFDO0NBQUEsQUF4QkQsSUF3QkM7U0F4QlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmLCBJbnB1dCwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5cbmltcG9ydCB7IFVuaXZlcnNhbFZhbGlkYXRvcnMgfSBmcm9tIFwiLi91bml2ZXJzYWwtdmFsaWRhdG9yc1wiO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW25vV2hpdGVzcGFjZV1bZm9ybUNvbnRyb2xOYW1lXSxbbm9XaGl0ZXNwYWNlXVtmb3JtQ29udHJvbF0sW25vV2hpdGVzcGFjZV1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gV2hpdGVTcGFjZVZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBXaGl0ZVNwYWNlVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQge1xuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm5vV2hpdGVzcGFjZTtcbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW25vRW1wdHlTdHJpbmddW2Zvcm1Db250cm9sTmFtZV0sW25vRW1wdHlTdHJpbmddW2Zvcm1Db250cm9sXSxbbm9FbXB0eVN0cmluZ11bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRW1wdHlTdHJpbmdWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgRW1wdHlTdHJpbmdWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCB7XG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubm9FbXB0eVN0cmluZztcbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW2lzTnVtYmVyXVtmb3JtQ29udHJvbE5hbWVdLFtpc051bWJlcl1bZm9ybUNvbnRyb2xdLFtpc051bWJlcl1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSXNOdW1iZXJWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgSXNOdW1iZXJWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCB7XG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMuaXNOdW1iZXI7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltpc0luUmFuZ2VdW2Zvcm1Db250cm9sTmFtZV0sW2lzSW5SYW5nZV1bZm9ybUNvbnRyb2xdLFtpc0luUmFuZ2VdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzSW5SYW5nZVZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBJc0luUmFuZ2VWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWluVmFsdWU6IG51bWJlcjtcbiAgQElucHV0KCkgbWF4VmFsdWU6IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLmlzSW5SYW5nZSh0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBsZXQgbWluVmFsdWUgPSB0aGlzLm1pblZhbHVlO1xuICAgIGxldCBtYXhWYWx1ZSA9IHRoaXMubWF4VmFsdWU7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIGlmIChjaGFuZ2VzLm1pblZhbHVlKSB7XG4gICAgICBtaW5WYWx1ZSA9IGNoYW5nZXMubWluVmFsdWUuY3VycmVudFZhbHVlO1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZXMubWluVmFsdWUuaXNGaXJzdENoYW5nZSgpID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLm1heFZhbHVlKSB7XG4gICAgICBtYXhWYWx1ZSA9IGNoYW5nZXMubWF4VmFsdWUuY3VycmVudFZhbHVlO1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZXMubWF4VmFsdWUuaXNGaXJzdENoYW5nZSgpID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMuaXNJblJhbmdlKG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT10ZXh0XVttYXhdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT10ZXh0XVttYXhdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXRleHRdW21heF1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF4VmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIE1heFZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtYXg6IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1heCh0aGlzLm1heCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubWF4ICYmICFjaGFuZ2VzLm1heC5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5tYXgoY2hhbmdlcy5tYXguY3VycmVudFZhbHVlKTtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPXRleHRdW21pbl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXRleHRdW21pbl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9dGV4dF1bbWluXVtuZ01vZGVsXVwiLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5WYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTWluVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG1pbjogbnVtYmVyO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubWluKHRoaXMubWluKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5taW4gJiYgIWNoYW5nZXMubWluLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1pbihjaGFuZ2VzLm1pbi5jdXJyZW50VmFsdWUpO1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cbiJdfQ==
import * as tslib_1 from "tslib";
import { Directive, forwardRef, Input } from "@angular/core";
import { NG_VALIDATORS } from "@angular/forms";
import { delay } from "rxjs/operators";
var EqualToDirective = /** @class */ (function () {
    function EqualToDirective() {
    }
    EqualToDirective_1 = EqualToDirective;
    EqualToDirective.prototype.validate = function (c) {
        var otherControl = typeof this.equalTo === "string" ? c.parent.get(this.equalTo) : this.equalTo;
        if (!this.subscription) {
            this.subscription = otherControl.valueChanges.pipe(delay(1)).subscribe(function () {
                c.updateValueAndValidity();
            });
        }
        return c.value !== otherControl.value ? { notEqualTo: true } : null;
    };
    EqualToDirective.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    EqualToDirective.prototype.ngOnChanges = function (changes) {
        if (changes.equalTo && !changes.equalTo.isFirstChange()) {
            this.onChange();
        }
    };
    EqualToDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var EqualToDirective_1;
    tslib_1.__decorate([
        Input()
    ], EqualToDirective.prototype, "equalTo", void 0);
    EqualToDirective = EqualToDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EqualToDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EqualToDirective);
    return EqualToDirective;
}());
export { EqualToDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXF1YWwtdG8uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXZhbGlkYXRvcnMvIiwic291cmNlcyI6WyJjb21wb25lbnRzL2VxdWFsLXRvL2VxdWFsLXRvLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUF1QyxNQUFNLGVBQWUsQ0FBQztBQUNsRyxPQUFPLEVBQW1CLGFBQWEsRUFBK0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3RixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFhdkM7SUFBQTtJQThCQSxDQUFDO3lCQTlCWSxnQkFBZ0I7SUFNM0IsbUNBQVEsR0FBUixVQUFTLENBQWtCO1FBQ3pCLElBQU0sWUFBWSxHQUFHLE9BQU8sSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUVsRyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztnQkFDckUsQ0FBQyxDQUFDLHNCQUFzQixFQUFFLENBQUM7WUFDN0IsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUNELE9BQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3RFLENBQUM7SUFFRCxzQ0FBVyxHQUFYO1FBQ0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQsc0NBQVcsR0FBWCxVQUFZLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDdkQsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQztJQUVELG9EQUF5QixHQUF6QixVQUEwQixFQUFjO1FBQ3RDLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7O0lBNUJRO1FBQVIsS0FBSyxFQUFFO3FEQUFtQztJQURoQyxnQkFBZ0I7UUFYNUIsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLHdFQUF3RTtZQUNsRixTQUFTLEVBQUU7Z0JBQ1Q7b0JBQ0UsT0FBTyxFQUFFLGFBQWE7b0JBQ3RCLDBDQUEwQztvQkFDMUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsa0JBQWdCLEVBQWhCLENBQWdCLENBQUM7b0JBQy9DLEtBQUssRUFBRSxJQUFJO2lCQUNaO2FBQ0Y7U0FDRixDQUFDO09BQ1csZ0JBQWdCLENBOEI1QjtJQUFELHVCQUFDO0NBQUEsQUE5QkQsSUE4QkM7U0E5QlksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmLCBJbnB1dCwgT25EZXN0cm95LCBTaW1wbGVDaGFuZ2VzLCBPbkNoYW5nZXMgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBkZWxheSB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW2VxdWFsVG9dW25nTW9kZWxdLCBbZXF1YWxUb11bZm9ybUNvbnRyb2xOYW1lXSwgW2VxdWFsVG9dW2Zvcm1Db250cm9sXVwiLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBFcXVhbFRvRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEVxdWFsVG9EaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgZXF1YWxUbzogc3RyaW5nIHwgQWJzdHJhY3RDb250cm9sO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIGNvbnN0IG90aGVyQ29udHJvbCA9IHR5cGVvZiB0aGlzLmVxdWFsVG8gPT09IFwic3RyaW5nXCIgPyBjLnBhcmVudC5nZXQodGhpcy5lcXVhbFRvKSA6IHRoaXMuZXF1YWxUbztcblxuICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gb3RoZXJDb250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKGRlbGF5KDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBjLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYy52YWx1ZSAhPT0gb3RoZXJDb250cm9sLnZhbHVlID8geyBub3RFcXVhbFRvOiB0cnVlIH0gOiBudWxsO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5lcXVhbFRvICYmICFjaGFuZ2VzLmVxdWFsVG8uaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuIl19
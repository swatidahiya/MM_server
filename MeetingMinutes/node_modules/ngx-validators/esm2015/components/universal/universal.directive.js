var WhiteSpaceValidatorDirective_1, EmptyStringValidatorDirective_1, IsNumberValidatorDirective_1, IsInRangeValidatorDirective_1, MaxValidatorDirective_1, MinValidatorDirective_1;
import * as tslib_1 from "tslib";
import { Directive, forwardRef, Input } from "@angular/core";
import { NG_VALIDATORS } from "@angular/forms";
import { UniversalValidators } from "./universal-validators";
let WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = class WhiteSpaceValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.noWhitespace;
    }
    validate(c) {
        return this.validator(c);
    }
};
WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => WhiteSpaceValidatorDirective_1),
                multi: true,
            },
        ],
    })
], WhiteSpaceValidatorDirective);
export { WhiteSpaceValidatorDirective };
let EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = class EmptyStringValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.noEmptyString;
    }
    validate(c) {
        return this.validator(c);
    }
};
EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => EmptyStringValidatorDirective_1),
                multi: true,
            },
        ],
    })
], EmptyStringValidatorDirective);
export { EmptyStringValidatorDirective };
let IsNumberValidatorDirective = IsNumberValidatorDirective_1 = class IsNumberValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.isNumber;
    }
    validate(c) {
        return this.validator(c);
    }
};
IsNumberValidatorDirective = IsNumberValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => IsNumberValidatorDirective_1),
                multi: true,
            },
        ],
    })
], IsNumberValidatorDirective);
export { IsNumberValidatorDirective };
let IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = class IsInRangeValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    }
    ngOnChanges(changes) {
        let minValue = this.minValue;
        let maxValue = this.maxValue;
        let changed = false;
        if (changes.minValue) {
            minValue = changes.minValue.currentValue;
            changed = changes.minValue.isFirstChange() ? false : true;
        }
        if (changes.maxValue) {
            maxValue = changes.maxValue.currentValue;
            changed = changes.maxValue.isFirstChange() ? false : true;
        }
        if (changed) {
            this.validator = UniversalValidators.isInRange(minValue, maxValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], IsInRangeValidatorDirective.prototype, "minValue", void 0);
tslib_1.__decorate([
    Input()
], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => IsInRangeValidatorDirective_1),
                multi: true,
            },
        ],
    })
], IsInRangeValidatorDirective);
export { IsInRangeValidatorDirective };
let MaxValidatorDirective = MaxValidatorDirective_1 = class MaxValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.max(this.max);
    }
    ngOnChanges(changes) {
        if (changes.max && !changes.max.isFirstChange()) {
            this.validator = UniversalValidators.max(changes.max.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], MaxValidatorDirective.prototype, "max", void 0);
MaxValidatorDirective = MaxValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MaxValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MaxValidatorDirective);
export { MaxValidatorDirective };
let MinValidatorDirective = MinValidatorDirective_1 = class MinValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.min(this.min);
    }
    ngOnChanges(changes) {
        if (changes.min && !changes.min.isFirstChange()) {
            this.validator = UniversalValidators.min(changes.min.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], MinValidatorDirective.prototype, "min", void 0);
MinValidatorDirective = MinValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MinValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MinValidatorDirective);
export { MinValidatorDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdmVyc2FsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC12YWxpZGF0b3JzLyIsInNvdXJjZXMiOlsiY29tcG9uZW50cy91bml2ZXJzYWwvdW5pdmVyc2FsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBb0MsTUFBTSxlQUFlLENBQUM7QUFDL0YsT0FBTyxFQUFtQixhQUFhLEVBQTRDLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUcsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFhN0QsSUFBYSw0QkFBNEIsb0NBQXpDLE1BQWEsNEJBQTRCO0lBR3ZDLFFBQVE7UUFDTixJQUFJLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLFlBQVksQ0FBQztJQUNwRCxDQUFDO0lBRUQsUUFBUSxDQUFDLENBQWtCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0NBQ0YsQ0FBQTtBQVZZLDRCQUE0QjtJQVh4QyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUscUZBQXFGO1FBQy9GLFNBQVMsRUFBRTtZQUNUO2dCQUNFLE9BQU8sRUFBRSxhQUFhO2dCQUN0QiwwQ0FBMEM7Z0JBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsOEJBQTRCLENBQUM7Z0JBQzNELEtBQUssRUFBRSxJQUFJO2FBQ1o7U0FDRjtLQUNGLENBQUM7R0FDVyw0QkFBNEIsQ0FVeEM7U0FWWSw0QkFBNEI7QUF1QnpDLElBQWEsNkJBQTZCLHFDQUExQyxNQUFhLDZCQUE2QjtJQUd4QyxRQUFRO1FBQ04sSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxhQUFhLENBQUM7SUFDckQsQ0FBQztJQUVELFFBQVEsQ0FBQyxDQUFrQjtRQUN6QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMs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QUFxQiw2QkFBbEMsTUFBYSxxQkFBcUI7SUFNaEMsUUFBUTtRQUNOLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDL0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNuRSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDakI7SUFDSCxDQUFDO0lBRUQsUUFBUSxDQUFDLENBQWtCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQseUJBQXlCLENBQUMsRUFBYztRQUN0QyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDO0NBQ0YsQ0FBQTtBQXZCVTtJQUFSLEtBQUssRUFBRTtrREFBYTtBQURWLHFCQUFxQjtJQVhqQyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsMEdBQTBHO1FBQ3BILFNBQVMsRUFBRTtZQUNUO2dCQUNFLE9BQU8sRUFBRSxhQUFhO2dCQUN0QiwwQ0FBMEM7Z0JBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQXFCLENBQUM7Z0JBQ3BELEtBQUssRUFBRSxJQUFJO2FBQ1o7U0FDRjtLQUNGLENBQUM7R0FDVyxxQkFBcUIsQ0F3QmpDO1NBeEJZLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBVbml2ZXJzYWxWYWxpZGF0b3JzIH0gZnJvbSBcIi4vdW5pdmVyc2FsLXZhbGlkYXRvcnNcIjtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltub1doaXRlc3BhY2VdW2Zvcm1Db250cm9sTmFtZV0sW25vV2hpdGVzcGFjZV1bZm9ybUNvbnRyb2xdLFtub1doaXRlc3BhY2VdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFdoaXRlU3BhY2VWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgV2hpdGVTcGFjZVZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0IHtcbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5ub1doaXRlc3BhY2U7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltub0VtcHR5U3RyaW5nXVtmb3JtQ29udHJvbE5hbWVdLFtub0VtcHR5U3RyaW5nXVtmb3JtQ29udHJvbF0sW25vRW1wdHlTdHJpbmddW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEVtcHR5U3RyaW5nVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEVtcHR5U3RyaW5nVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQge1xuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm5vRW1wdHlTdHJpbmc7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltpc051bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxbaXNOdW1iZXJdW2Zvcm1Db250cm9sXSxbaXNOdW1iZXJdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzTnVtYmVyVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIElzTnVtYmVyVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQge1xuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLmlzTnVtYmVyO1xuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogXCJbaXNJblJhbmdlXVtmb3JtQ29udHJvbE5hbWVdLFtpc0luUmFuZ2VdW2Zvcm1Db250cm9sXSxbaXNJblJhbmdlXVtuZ01vZGVsXVwiLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJc0luUmFuZ2VWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgSXNJblJhbmdlVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG1pblZhbHVlOiBudW1iZXI7XG4gIEBJbnB1dCgpIG1heFZhbHVlOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5pc0luUmFuZ2UodGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgbGV0IG1pblZhbHVlID0gdGhpcy5taW5WYWx1ZTtcbiAgICBsZXQgbWF4VmFsdWUgPSB0aGlzLm1heFZhbHVlO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hhbmdlcy5taW5WYWx1ZSkge1xuICAgICAgbWluVmFsdWUgPSBjaGFuZ2VzLm1pblZhbHVlLmN1cnJlbnRWYWx1ZTtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VzLm1pblZhbHVlLmlzRmlyc3RDaGFuZ2UoKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5tYXhWYWx1ZSkge1xuICAgICAgbWF4VmFsdWUgPSBjaGFuZ2VzLm1heFZhbHVlLmN1cnJlbnRWYWx1ZTtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VzLm1heFZhbHVlLmlzRmlyc3RDaGFuZ2UoKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLmlzSW5SYW5nZShtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9dGV4dF1bbWF4XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9dGV4dF1bbWF4XVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT10ZXh0XVttYXhdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heFZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBNYXhWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWF4OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5tYXgodGhpcy5tYXgpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLm1heCAmJiAhY2hhbmdlcy5tYXguaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubWF4KGNoYW5nZXMubWF4LmN1cnJlbnRWYWx1ZSk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT10ZXh0XVttaW5dW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT10ZXh0XVttaW5dW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXRleHRdW21pbl1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWluVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIE1pblZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtaW46IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1pbih0aGlzLm1pbik7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubWluICYmICFjaGFuZ2VzLm1pbi5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5taW4oY2hhbmdlcy5taW4uY3VycmVudFZhbHVlKTtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG4iXX0=
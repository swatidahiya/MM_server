(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-validators', ['exports', '@angular/core', '@angular/forms', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['ngx-validators'] = {}, global.ng.core, global.ng.forms, global.rxjs.operators));
}(this, (function (exports, core, forms, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    var AbstractControlUtil = /** @class */ (function () {
        function AbstractControlUtil() {
        }
        AbstractControlUtil.isNotPresent = function (control) {
            var value = control.value;
            if (value === undefined || value === null) {
                return true;
            }
            return value !== "" ? false : true;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        AbstractControlUtil.addError = function (control, errorId, value) {
            var _a;
            if (!control.errors) {
                control.setErrors((_a = {}, _a[errorId] = value, _a));
            }
            else if (!control.hasError(errorId)) {
                control.errors[errorId] = value;
            }
        };
        AbstractControlUtil.removeError = function (control, errorId) {
            if (control.errors && control.hasError(errorId)) {
                if (Object.keys(control.errors).length > 1) {
                    delete control.errors[errorId];
                }
                else {
                    control.setErrors(null);
                }
            }
        };
        return AbstractControlUtil;
    }());

    // tslint:disable-next-line:variable-name
    var PasswordValidators = /** @class */ (function () {
        function PasswordValidators() {
        }
        PasswordValidators.repeatCharacterRegexRule = function (repeatCount) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var repeatDec = repeatCount - 1;
                var pattern = "([^\\x00-\\x1F])\\1{" + repeatDec + "}";
                if (control.value !== "" && new RegExp(pattern).test(control.value)) {
                    return { repeatCharacterRegexRule: { repeatCount: repeatCount } };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.allowedCharacterRule = function (allowedChars) {
            var validator = function (control) {
                var e_1, _a;
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                var valid = true;
                var invalidChars = [];
                try {
                    for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                        var char = value_1_1.value;
                        if (allowedChars.indexOf(char) === -1) {
                            valid = false;
                            if (invalidChars.indexOf(char) === -1) {
                                invalidChars.push(char);
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (!valid) {
                    return {
                        allowedCharacterRule: {
                            invalidChars: invalidChars,
                            allowedChars: allowedChars,
                        },
                    };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.alphabeticalCharacterRule = function (amount) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (value.length === 0) {
                    return undefined;
                }
                var pattern = /[^A-Za-z]+/g;
                var stripped = value.replace(pattern, "");
                if (stripped.length < amount) {
                    return {
                        alphabeticalCharacterRule: {
                            required: amount,
                            actual: stripped.length,
                        },
                    };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.digitCharacterRule = function (amount) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (value.length === 0) {
                    return undefined;
                }
                var pattern = /[^0-9\.]+/g;
                var stripped = value.replace(pattern, "");
                if (stripped.length < amount) {
                    return {
                        digitCharacterRule: { required: amount, actual: stripped.length },
                    };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.lowercaseCharacterRule = function (amount) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (value.length === 0) {
                    return undefined;
                }
                var pattern = /[^a-z]+/g;
                var stripped = value.replace(pattern, "");
                if (stripped.length < amount) {
                    return {
                        lowercaseCharacterRule: { required: amount, actual: stripped.length },
                    };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.uppercaseCharacterRule = function (amount) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (value.length === 0) {
                    return undefined;
                }
                var pattern = /[^A-Z]+/g;
                var stripped = value.replace(pattern, "");
                if (stripped.length < amount) {
                    return {
                        uppercaseCharacterRule: { required: amount, actual: stripped.length },
                    };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.specialCharacterRule = function (amount) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (value.length === 0) {
                    return undefined;
                }
                var pattern = /[\w\s]+/g;
                var stripped = value.replace(pattern, "");
                if (stripped.length < amount) {
                    return {
                        specialCharacterRule: { required: amount, actual: stripped.length },
                    };
                }
                return undefined;
            };
            return validator;
        };
        PasswordValidators.mismatchedPasswords = function (passwordControlName, confirmPasswordControlName) {
            var validator = function (group) {
                var newPasswordValue = group.get(passwordControlName ? passwordControlName : "newPassword").value;
                var newPasswordConfirmValue = group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword").value;
                if (newPasswordValue !== newPasswordConfirmValue) {
                    AbstractControlUtil.addError(group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword"), "mismatchedPasswords", true);
                    return { mismatchedPasswords: true };
                }
                else {
                    AbstractControlUtil.removeError(group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword"), "mismatchedPasswords");
                }
                return undefined;
            };
            return validator;
        };
        return PasswordValidators;
    }());

    /*
     * Code fromMailcheck https://github.com/mailcheck/mailcheck
     * Author
     * Derrick Ko (@derrickko)
     *
     * Released under the MIT License.
     *
     * v 1.1.2
     */
    var EmailSuggestion = /** @class */ (function () {
        function EmailSuggestion() {
            this.defaultOptions = {
                domains: [
                    "msn.com",
                    "bellsouth.net",
                    "telus.net",
                    "comcast.net",
                    "optusnet.com.au",
                    "earthlink.net",
                    "qq.com",
                    "sky.com",
                    "icloud.com",
                    "mac.com",
                    "sympatico.ca",
                    "googlemail.com",
                    "att.net",
                    "xtra.co.nz",
                    "web.de",
                    "cox.net",
                    "gmail.com",
                    "ymail.com",
                    "yahoo.com",
                    "aim.com",
                    "rogers.com",
                    "verizon.net",
                    "rocketmail.com",
                    "google.com",
                    "optonline.net",
                    "sbcglobal.net",
                    "aol.com",
                    "me.com",
                    "btinternet.com",
                    "charter.net",
                    "shaw.ca",
                ],
                secondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],
                topLevelDomains: [
                    "com",
                    "com.au",
                    "com.tw",
                    "ca",
                    "co.nz",
                    "co.uk",
                    "de",
                    "fr",
                    "it",
                    "ru",
                    "net",
                    "org",
                    "edu",
                    "gov",
                    "jp",
                    "nl",
                    "kr",
                    "se",
                    "eu",
                    "ie",
                    "co.il",
                    "us",
                    "at",
                    "be",
                    "dk",
                    "hk",
                    "es",
                    "gr",
                    "ch",
                    "no",
                    "cz",
                    "in",
                    "net",
                    "net.au",
                    "info",
                    "biz",
                    "mil",
                    "co.jp",
                    "sg",
                    "hu",
                    "uk",
                ],
            };
        }
        EmailSuggestion.prototype.suggest = function (email, options) {
            var opt = this.defaultOptions;
            if (options !== undefined) {
                opt = options;
            }
            var emailParts = this.splitEmail(email.toLowerCase());
            if (!emailParts) {
                return undefined;
            }
            if (opt.secondLevelDomains && opt.topLevelDomains) {
                // If the email is a valid 2nd-level + top-level, do not suggest anything.
                if (opt.secondLevelDomains.indexOf(emailParts.secondLevelDomain) !== -1 &&
                    opt.topLevelDomains.indexOf(emailParts.topLevelDomain) !== -1) {
                    return undefined;
                }
            }
            var closestDomain = this.findClosestDomain(emailParts.domain, opt.domains, 2);
            if (closestDomain) {
                if (closestDomain === emailParts.domain) {
                    // The email address exactly matches one of the supplied domains; do not return a suggestion.
                    return undefined;
                }
                else {
                    // The email address closely matches one of the supplied domains; return a suggestion
                    return {
                        suggestion: {
                            address: emailParts.address,
                            domain: closestDomain,
                            full: emailParts.address + "@" + closestDomain,
                        },
                    };
                }
            }
            var closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, opt.secondLevelDomains, 2);
            var closestTopLevelDomain = this.findClosestDomain(emailParts.topLevelDomain, opt.topLevelDomains, 2);
            if (emailParts.domain) {
                closestDomain = emailParts.domain;
                var rtrn = false;
                if (closestSecondLevelDomain && closestSecondLevelDomain !== emailParts.secondLevelDomain) {
                    // The email address may have a mispelled second-level domain; return a suggestion
                    closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain);
                    rtrn = true;
                }
                if (closestTopLevelDomain &&
                    closestTopLevelDomain !== emailParts.topLevelDomain &&
                    emailParts.secondLevelDomain !== "") {
                    // The email address may have a mispelled top-level domain; return a suggestion
                    closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain);
                    rtrn = true;
                }
                if (rtrn) {
                    return {
                        suggestion: {
                            address: emailParts.address,
                            domain: closestDomain,
                            full: emailParts.address + "@" + closestDomain,
                        },
                    };
                }
            }
            /* The email address exactly matches one of the supplied domains, does not closely
             * match any domain and does not appear to simply have a mispelled top-level domain,
             * or is an invalid email address; do not return a suggestion.
             */
            return undefined;
        };
        EmailSuggestion.prototype.splitEmail = function (email) {
            var parts = email.trim().split("@");
            if (parts.length < 2) {
                return undefined;
            }
            // tslint:disable-next-line: prefer-for-of
            for (var i = 0; i < parts.length; i++) {
                if (parts[i] === "") {
                    return undefined;
                }
            }
            var result = {
                topLevelDomain: "",
                secondLevelDomain: "",
                domain: parts.pop(),
                address: "",
            };
            var domainParts = result.domain.split(".");
            if (domainParts.length === 0) {
                return undefined;
            }
            else if (domainParts.length === 1) {
                result.topLevelDomain = domainParts[0];
            }
            else {
                // The address has a domain and a top-level domain
                result.secondLevelDomain = domainParts[0];
                for (var j = 1; j < domainParts.length; j++) {
                    result.topLevelDomain += domainParts[j] + ".";
                }
                result.topLevelDomain = result.topLevelDomain.substring(0, result.topLevelDomain.length - 1);
            }
            result.address = parts.join("@");
            return result;
        };
        EmailSuggestion.prototype.findClosestDomain = function (domain, domains, threshold) {
            var dist;
            var minDist = Infinity;
            var closestDomain = null;
            if (!domain || !domains) {
                return undefined;
            }
            // tslint:disable-next-line: prefer-for-of
            for (var i = 0; i < domains.length; i++) {
                if (domain === domains[i]) {
                    return domain;
                }
                dist = this.sift4Distance(domain, domains[i], 5);
                if (dist < minDist) {
                    minDist = dist;
                    closestDomain = domains[i];
                }
            }
            if (minDist <= threshold && closestDomain !== null) {
                return closestDomain;
            }
            else {
                return undefined;
            }
        };
        EmailSuggestion.prototype.sift4Distance = function (s1, s2, maxOffset) {
            // sift4: https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
            if (maxOffset === undefined) {
                maxOffset = 5; // default
            }
            if (!s1 || !s1.length) {
                if (!s2) {
                    return 0;
                }
                return s2.length;
            }
            if (!s2 || !s2.length) {
                return s1.length;
            }
            var l1 = s1.length;
            var l2 = s2.length;
            var c1 = 0; // cursor for string 1
            var c2 = 0; // cursor for string 2
            var lcss = 0; // largest common subsequence
            var localCS = 0; // local common substring
            var trans = 0; // number of transpositions ('ab' vs 'ba')
            var offsetArr = []; // offset pair array, for computing the transpositions
            while (c1 < l1 && c2 < l2) {
                if (s1.charAt(c1) === s2.charAt(c2)) {
                    localCS++;
                    var isTrans = false;
                    // see if current match is a transposition
                    var i = 0;
                    while (i < offsetArr.length) {
                        var ofs = offsetArr[i];
                        if (c1 <= ofs.c1 || c2 <= ofs.c2) {
                            // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                            isTrans = Math.abs(c2 - c1) >= Math.abs(ofs.c2 - ofs.c1);
                            if (isTrans) {
                                trans++;
                            }
                            else {
                                if (!ofs.trans) {
                                    ofs.trans = true;
                                    trans++;
                                }
                            }
                            break;
                        }
                        else {
                            if (c1 > ofs.c2 && c2 > ofs.c1) {
                                offsetArr.splice(i, 1);
                            }
                            else {
                                i++;
                            }
                        }
                    }
                    offsetArr.push({
                        c1: c1,
                        c2: c2,
                        trans: isTrans,
                    });
                }
                else {
                    lcss += localCS;
                    localCS = 0;
                    if (c1 !== c2) {
                        c1 = c2 = Math.min(c1, c2); // using min allows the computation of transpositions
                    }
                    // if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
                    // so that we can have only one code block handling matches
                    for (var j = 0; j < maxOffset && (c1 + j < l1 || c2 + j < l2); j++) {
                        if (c1 + j < l1 && s1.charAt(c1 + j) === s2.charAt(c2)) {
                            c1 += j - 1;
                            c2--;
                            break;
                        }
                        if (c2 + j < l2 && s1.charAt(c1) === s2.charAt(c2 + j)) {
                            c1--;
                            c2 += j - 1;
                            break;
                        }
                    }
                }
                c1++;
                c2++;
                // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
                if (c1 >= l1 || c2 >= l2) {
                    lcss += localCS;
                    localCS = 0;
                    c1 = c2 = Math.min(c1, c2);
                }
            }
            lcss += localCS;
            return Math.round(Math.max(l1, l2) - lcss + trans); // add the cost of transpositions to the final result
        };
        return EmailSuggestion;
    }());

    var EmailValidators = /** @class */ (function () {
        function EmailValidators() {
        }
        EmailValidators.simple = function (control) {
            if (AbstractControlUtil.isNotPresent(control)) {
                return undefined;
            }
            var pattern = /.+@.+\..+/i;
            if (pattern.test(control.value)) {
                return undefined;
            }
            return { simpleEmailRule: true };
        };
        // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
        EmailValidators.normal = function (control) {
            if (AbstractControlUtil.isNotPresent(control)) {
                return undefined;
            }
            // tslint:disable-next-line:max-line-length
            var pattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
            if (pattern.test(control.value)) {
                return undefined;
            }
            return { normalEmailRule: true };
        };
        EmailValidators.suggest = function (options) {
            var _this = this;
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control)) {
                    return undefined;
                }
                return _this.emailSuggestion.suggest(control.value, options);
            };
            return validator;
        };
        EmailValidators.emailSuggestion = new EmailSuggestion();
        return EmailValidators;
    }());

    var UniversalValidators = /** @class */ (function () {
        function UniversalValidators() {
        }
        UniversalValidators.noWhitespace = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var pattern = "\\s";
            if (new RegExp(pattern).test(control.value)) {
                return { noWhitespaceRequired: true };
            }
            return undefined;
        };
        UniversalValidators.noEmptyString = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (control.value.trim().length === 0) {
                return { noEmptyString: true };
            }
            return undefined;
        };
        UniversalValidators.isNumber = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            return undefined;
        };
        UniversalValidators.isInRange = function (minValue, maxValue) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                if (isNaN(control.value)) {
                    return { numberRequired: true };
                }
                if (+control.value < minValue) {
                    return {
                        rangeValueToSmall: {
                            requiredMinValue: minValue,
                            requiredMaxValue: maxValue,
                            actual: control.value,
                        },
                    };
                }
                if (+control.value > maxValue) {
                    return {
                        rangeValueToBig: {
                            requiredMinValue: minValue,
                            requiredMaxValue: maxValue,
                            actual: control.value,
                        },
                    };
                }
                else {
                    return undefined;
                }
            };
            return validator;
        };
        UniversalValidators.minLength = function (minLength) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (value.length >= minLength) {
                    return undefined;
                }
                return {
                    minLength: { requiredMinLength: minLength, actualLength: value.length },
                };
            };
            return validator;
        };
        UniversalValidators.maxLength = function (maxLength) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (maxLength >= value.length) {
                    return undefined;
                }
                return {
                    maxLength: { requiredMaxLength: maxLength, actualLength: value.length },
                };
            };
            return validator;
        };
        UniversalValidators.min = function (min) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (isNaN(control.value)) {
                    return { numberRequired: true };
                }
                if (+value >= min) {
                    return undefined;
                }
                return { min: { required: min, actual: control.value } };
            };
            return validator;
        };
        UniversalValidators.max = function (max) {
            var validator = function (control) {
                if (AbstractControlUtil.isNotPresent(control))
                    return undefined;
                var value = control.value;
                if (isNaN(control.value)) {
                    return { numberRequired: true };
                }
                if (max >= +value) {
                    return undefined;
                }
                return { max: { required: max, actual: control.value } };
            };
            return validator;
        };
        return UniversalValidators;
    }());

    var visaRegex = "^(?:4[0-9]{12})(?:[0-9]{3})?$";
    var americanExpressRegex = "^(?:3[47][0-9]{13})$";
    var maestroRegex = "^(?:(?:5[0678]\\d\\d|6304|6390|67\\d\\d)\\d{8,15})$";
    var jcbRegex = "^(?:(?:2131|1800|35\\d{3})\\d{11})$";
    var discoverRegex = "^(?:6(?:011|5[0-9]{2})(?:[0-9]{12}))$";
    var dinersclubRegex = "^(?:3(?:0[0-5]|[68][0-9])[0-9]{11})$";
    var mastercardRegex = "^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$";
    var CreditCardValidators = /** @class */ (function () {
        function CreditCardValidators() {
        }
        CreditCardValidators.isCreditCard = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(americanExpressRegex +
                "|" +
                visaRegex +
                "|" +
                maestroRegex +
                "|" +
                jcbRegex +
                "|" +
                discoverRegex +
                "|" +
                mastercardRegex +
                "|" +
                dinersclubRegex).test(control.value)) {
                return undefined;
            }
            return { creditcard: true };
        };
        CreditCardValidators.americanExpress = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(americanExpressRegex).test(control.value)) {
                return undefined;
            }
            return { americanExpress: true };
        };
        CreditCardValidators.dinersclub = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(dinersclubRegex).test(control.value)) {
                return undefined;
            }
            return { dinersclub: true };
        };
        CreditCardValidators.discover = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(discoverRegex).test(control.value)) {
                return undefined;
            }
            return { discover: true };
        };
        CreditCardValidators.jcb = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(jcbRegex).test(control.value)) {
                return undefined;
            }
            return { jcb: true };
        };
        CreditCardValidators.maestro = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(maestroRegex).test(control.value)) {
                return undefined;
            }
            return { maestro: true };
        };
        CreditCardValidators.mastercard = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(mastercardRegex).test(control.value)) {
                return undefined;
            }
            return { mastercard: true };
        };
        CreditCardValidators.visa = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (new RegExp(visaRegex).test(control.value)) {
                return undefined;
            }
            return { visa: true };
        };
        return CreditCardValidators;
    }());

    var PasswordValidatorDirective = /** @class */ (function () {
        function PasswordValidatorDirective() {
            this.repeatCharacter = 4;
            this.alphabeticalCharacter = 1;
            this.digitCharacter = 1;
            this.lowercaseCharacter = 1;
            this.uppercaseCharacter = 1;
        }
        PasswordValidatorDirective_1 = PasswordValidatorDirective;
        PasswordValidatorDirective.prototype.ngOnInit = function () {
            this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(this.repeatCharacter);
            this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(this.alphabeticalCharacter);
            this.digitCharacterValidator = PasswordValidators.digitCharacterRule(this.digitCharacter);
            this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(this.lowercaseCharacter);
            this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(this.uppercaseCharacter);
        };
        PasswordValidatorDirective.prototype.ngOnChanges = function (changes) {
            var inputChanged = false;
            if (changes.repeatCharacter) {
                this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(changes.repeatCharacter.currentValue);
                inputChanged = changes.repeatCharacter.isFirstChange() ? false : true;
            }
            if (changes.alphabeticalCharacter) {
                this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(changes.alphabeticalCharacter.currentValue);
                inputChanged = changes.alphabeticalCharacter.isFirstChange() ? false : true;
            }
            if (changes.digitCharacter) {
                this.digitCharacterValidator = PasswordValidators.digitCharacterRule(changes.digitCharacter.currentValue);
                inputChanged = changes.digitCharacter.isFirstChange() ? false : true;
            }
            if (changes.lowercaseCharacter) {
                this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(changes.lowercaseCharacter.currentValue);
                inputChanged = changes.lowercaseCharacter.isFirstChange() ? false : true;
            }
            if (changes.uppercaseCharacter) {
                this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(changes.uppercaseCharacter.currentValue);
                inputChanged = changes.uppercaseCharacter.isFirstChange() ? false : true;
            }
            if (inputChanged) {
                this.onChange();
            }
        };
        PasswordValidatorDirective.prototype.validate = function (c) {
            var compose = forms.Validators.compose([
                this.repeatCharacterValidator,
                this.digitCharacterValidator,
                this.alphabeticalCharacterValidator,
                this.lowercaseCharacterValidator,
                this.uppercaseCharacterValidator,
            ]);
            return compose(c);
        };
        PasswordValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        var PasswordValidatorDirective_1;
        __decorate([
            core.Input()
        ], PasswordValidatorDirective.prototype, "repeatCharacter", void 0);
        __decorate([
            core.Input()
        ], PasswordValidatorDirective.prototype, "alphabeticalCharacter", void 0);
        __decorate([
            core.Input()
        ], PasswordValidatorDirective.prototype, "digitCharacter", void 0);
        __decorate([
            core.Input()
        ], PasswordValidatorDirective.prototype, "lowercaseCharacter", void 0);
        __decorate([
            core.Input()
        ], PasswordValidatorDirective.prototype, "uppercaseCharacter", void 0);
        PasswordValidatorDirective = PasswordValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[password][formControlName],[password][formControl],[password][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return PasswordValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], PasswordValidatorDirective);
        return PasswordValidatorDirective;
    }());

    var EmailValidatorDirective = /** @class */ (function () {
        function EmailValidatorDirective() {
            this.email = "normal";
        }
        EmailValidatorDirective_1 = EmailValidatorDirective;
        EmailValidatorDirective.prototype.ngOnInit = function () {
            this.setValidator(this.email);
        };
        EmailValidatorDirective.prototype.setValidator = function (type) {
            switch (type) {
                case "simple":
                    this.validator = EmailValidators.simple;
                    break;
                case "normal":
                    this.validator = EmailValidators.normal;
                    break;
                default:
                    this.validator = EmailValidators.normal;
                    break;
            }
        };
        EmailValidatorDirective.prototype.ngOnChanges = function (changes) {
            if (changes.email && !changes.email.isFirstChange()) {
                this.setValidator(changes.email.currentValue);
                this.onChange();
            }
        };
        EmailValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        EmailValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        var EmailValidatorDirective_1;
        __decorate([
            core.Input()
        ], EmailValidatorDirective.prototype, "email", void 0);
        EmailValidatorDirective = EmailValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[email][formControlName],[email][formControl],[email][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return EmailValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], EmailValidatorDirective);
        return EmailValidatorDirective;
    }());
    var EmailSuggestValidatorDirective = /** @class */ (function () {
        function EmailSuggestValidatorDirective() {
        }
        EmailSuggestValidatorDirective_1 = EmailSuggestValidatorDirective;
        EmailSuggestValidatorDirective.prototype.ngOnInit = function () {
            this.validator = EmailValidators.suggest(this.emailSuggest);
        };
        EmailSuggestValidatorDirective.prototype.ngOnChanges = function (changes) {
            if (changes.emailSuggest && !changes.emailSuggest.isFirstChange()) {
                this.validator = EmailValidators.suggest(changes.emailSuggest.currentValue);
                this.onChange();
            }
        };
        EmailSuggestValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        EmailSuggestValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        var EmailSuggestValidatorDirective_1;
        __decorate([
            core.Input()
        ], EmailSuggestValidatorDirective.prototype, "emailSuggest", void 0);
        EmailSuggestValidatorDirective = EmailSuggestValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[emailSuggest][formControlName],[emailSuggest][formControl],[emailSuggest][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return EmailSuggestValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], EmailSuggestValidatorDirective);
        return EmailSuggestValidatorDirective;
    }());

    var WhiteSpaceValidatorDirective = /** @class */ (function () {
        function WhiteSpaceValidatorDirective() {
        }
        WhiteSpaceValidatorDirective_1 = WhiteSpaceValidatorDirective;
        WhiteSpaceValidatorDirective.prototype.ngOnInit = function () {
            this.validator = UniversalValidators.noWhitespace;
        };
        WhiteSpaceValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        var WhiteSpaceValidatorDirective_1;
        WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return WhiteSpaceValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], WhiteSpaceValidatorDirective);
        return WhiteSpaceValidatorDirective;
    }());
    var EmptyStringValidatorDirective = /** @class */ (function () {
        function EmptyStringValidatorDirective() {
        }
        EmptyStringValidatorDirective_1 = EmptyStringValidatorDirective;
        EmptyStringValidatorDirective.prototype.ngOnInit = function () {
            this.validator = UniversalValidators.noEmptyString;
        };
        EmptyStringValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        var EmptyStringValidatorDirective_1;
        EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return EmptyStringValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], EmptyStringValidatorDirective);
        return EmptyStringValidatorDirective;
    }());
    var IsNumberValidatorDirective = /** @class */ (function () {
        function IsNumberValidatorDirective() {
        }
        IsNumberValidatorDirective_1 = IsNumberValidatorDirective;
        IsNumberValidatorDirective.prototype.ngOnInit = function () {
            this.validator = UniversalValidators.isNumber;
        };
        IsNumberValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        var IsNumberValidatorDirective_1;
        IsNumberValidatorDirective = IsNumberValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return IsNumberValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], IsNumberValidatorDirective);
        return IsNumberValidatorDirective;
    }());
    var IsInRangeValidatorDirective = /** @class */ (function () {
        function IsInRangeValidatorDirective() {
        }
        IsInRangeValidatorDirective_1 = IsInRangeValidatorDirective;
        IsInRangeValidatorDirective.prototype.ngOnInit = function () {
            this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
        };
        IsInRangeValidatorDirective.prototype.ngOnChanges = function (changes) {
            var minValue = this.minValue;
            var maxValue = this.maxValue;
            var changed = false;
            if (changes.minValue) {
                minValue = changes.minValue.currentValue;
                changed = changes.minValue.isFirstChange() ? false : true;
            }
            if (changes.maxValue) {
                maxValue = changes.maxValue.currentValue;
                changed = changes.maxValue.isFirstChange() ? false : true;
            }
            if (changed) {
                this.validator = UniversalValidators.isInRange(minValue, maxValue);
                this.onChange();
            }
        };
        IsInRangeValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        IsInRangeValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        var IsInRangeValidatorDirective_1;
        __decorate([
            core.Input()
        ], IsInRangeValidatorDirective.prototype, "minValue", void 0);
        __decorate([
            core.Input()
        ], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
        IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return IsInRangeValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], IsInRangeValidatorDirective);
        return IsInRangeValidatorDirective;
    }());
    var MaxValidatorDirective = /** @class */ (function () {
        function MaxValidatorDirective() {
        }
        MaxValidatorDirective_1 = MaxValidatorDirective;
        MaxValidatorDirective.prototype.ngOnInit = function () {
            this.validator = UniversalValidators.max(this.max);
        };
        MaxValidatorDirective.prototype.ngOnChanges = function (changes) {
            if (changes.max && !changes.max.isFirstChange()) {
                this.validator = UniversalValidators.max(changes.max.currentValue);
                this.onChange();
            }
        };
        MaxValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        MaxValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        var MaxValidatorDirective_1;
        __decorate([
            core.Input()
        ], MaxValidatorDirective.prototype, "max", void 0);
        MaxValidatorDirective = MaxValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return MaxValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], MaxValidatorDirective);
        return MaxValidatorDirective;
    }());
    var MinValidatorDirective = /** @class */ (function () {
        function MinValidatorDirective() {
        }
        MinValidatorDirective_1 = MinValidatorDirective;
        MinValidatorDirective.prototype.ngOnInit = function () {
            this.validator = UniversalValidators.min(this.min);
        };
        MinValidatorDirective.prototype.ngOnChanges = function (changes) {
            if (changes.min && !changes.min.isFirstChange()) {
                this.validator = UniversalValidators.min(changes.min.currentValue);
                this.onChange();
            }
        };
        MinValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        MinValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        var MinValidatorDirective_1;
        __decorate([
            core.Input()
        ], MinValidatorDirective.prototype, "min", void 0);
        MinValidatorDirective = MinValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return MinValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], MinValidatorDirective);
        return MinValidatorDirective;
    }());

    var CreditCardValidatorDirective = /** @class */ (function () {
        function CreditCardValidatorDirective() {
            this.creditCard = "all";
        }
        CreditCardValidatorDirective_1 = CreditCardValidatorDirective;
        CreditCardValidatorDirective.prototype.ngOnInit = function () {
            this.setCreditcardValidator(this.creditCard);
        };
        CreditCardValidatorDirective.prototype.setCreditcardValidator = function (type) {
            switch (type) {
                case "all":
                    this.validator = CreditCardValidators.isCreditCard;
                    break;
                case "americanExpress":
                    this.validator = CreditCardValidators.americanExpress;
                    break;
                case "dinersclub":
                    this.validator = CreditCardValidators.dinersclub;
                    break;
                case "discover":
                    this.validator = CreditCardValidators.discover;
                    break;
                case "jcb":
                    this.validator = CreditCardValidators.jcb;
                    break;
                case "maestro":
                    this.validator = CreditCardValidators.maestro;
                    break;
                case "mastercard":
                    this.validator = CreditCardValidators.mastercard;
                    break;
                case "visa":
                    this.validator = CreditCardValidators.visa;
                    break;
                default:
                    this.validator = CreditCardValidators.isCreditCard;
                    break;
            }
        };
        CreditCardValidatorDirective.prototype.ngOnChanges = function (changes) {
            if (changes.creditCard && !changes.creditCard.isFirstChange()) {
                this.setCreditcardValidator(changes.creditCard.currentValue);
                this.onChange();
            }
        };
        CreditCardValidatorDirective.prototype.validate = function (c) {
            return this.validator(c);
        };
        CreditCardValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        var CreditCardValidatorDirective_1;
        __decorate([
            core.Input()
        ], CreditCardValidatorDirective.prototype, "creditCard", void 0);
        CreditCardValidatorDirective = CreditCardValidatorDirective_1 = __decorate([
            core.Directive({
                selector: "[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // eslint-disable-next-line @typescript-eslint/no-use-before-define
                        useExisting: core.forwardRef(function () { return CreditCardValidatorDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], CreditCardValidatorDirective);
        return CreditCardValidatorDirective;
    }());

    var EqualToDirective = /** @class */ (function () {
        function EqualToDirective() {
        }
        EqualToDirective_1 = EqualToDirective;
        EqualToDirective.prototype.validate = function (c) {
            var otherControl = typeof this.equalTo === "string" ? c.parent.get(this.equalTo) : this.equalTo;
            if (!this.subscription) {
                this.subscription = otherControl.valueChanges.pipe(operators.delay(1)).subscribe(function () {
                    c.updateValueAndValidity();
                });
            }
            return c.value !== otherControl.value ? { notEqualTo: true } : null;
        };
        EqualToDirective.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        EqualToDirective.prototype.ngOnChanges = function (changes) {
            if (changes.equalTo && !changes.equalTo.isFirstChange()) {
                this.onChange();
            }
        };
        EqualToDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onChange = fn;
        };
        var EqualToDirective_1;
        __decorate([
            core.Input()
        ], EqualToDirective.prototype, "equalTo", void 0);
        EqualToDirective = EqualToDirective_1 = __decorate([
            core.Directive({
                selector: "[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]",
                providers: [
                    {
                        provide: forms.NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: core.forwardRef(function () { return EqualToDirective_1; }),
                        multi: true,
                    },
                ],
            })
        ], EqualToDirective);
        return EqualToDirective;
    }());

    var ValidatorsModule = /** @class */ (function () {
        function ValidatorsModule() {
        }
        ValidatorsModule = __decorate([
            core.NgModule({
                declarations: [
                    CreditCardValidatorDirective,
                    EmailValidatorDirective,
                    EmailSuggestValidatorDirective,
                    PasswordValidatorDirective,
                    IsInRangeValidatorDirective,
                    IsNumberValidatorDirective,
                    MaxValidatorDirective,
                    MinValidatorDirective,
                    WhiteSpaceValidatorDirective,
                    EmptyStringValidatorDirective,
                    EqualToDirective,
                ],
                exports: [
                    CreditCardValidatorDirective,
                    EmailValidatorDirective,
                    EmailSuggestValidatorDirective,
                    PasswordValidatorDirective,
                    IsInRangeValidatorDirective,
                    IsNumberValidatorDirective,
                    MaxValidatorDirective,
                    MinValidatorDirective,
                    WhiteSpaceValidatorDirective,
                    EmptyStringValidatorDirective,
                    EqualToDirective,
                ],
            })
        ], ValidatorsModule);
        return ValidatorsModule;
    }());

    var EqualToValidator = /** @class */ (function () {
        function EqualToValidator() {
        }
        EqualToValidator.equalTo = function (c1Name, c2Name) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var validator = function (parent) {
                var c1 = parent.get(c1Name);
                var c2 = parent.get(c2Name);
                if (c1.value === c2.value) {
                    AbstractControlUtil.removeError(c2, "notEqualTo");
                }
                else {
                    AbstractControlUtil.addError(c2, "notEqualTo", true);
                }
            };
            return validator;
        };
        return EqualToValidator;
    }());

    exports.AbstractControlUtil = AbstractControlUtil;
    exports.CreditCardValidatorDirective = CreditCardValidatorDirective;
    exports.CreditCardValidators = CreditCardValidators;
    exports.EmailSuggestValidatorDirective = EmailSuggestValidatorDirective;
    exports.EmailSuggestion = EmailSuggestion;
    exports.EmailValidatorDirective = EmailValidatorDirective;
    exports.EmailValidators = EmailValidators;
    exports.EmptyStringValidatorDirective = EmptyStringValidatorDirective;
    exports.EqualToDirective = EqualToDirective;
    exports.EqualToValidator = EqualToValidator;
    exports.IsInRangeValidatorDirective = IsInRangeValidatorDirective;
    exports.IsNumberValidatorDirective = IsNumberValidatorDirective;
    exports.MaxValidatorDirective = MaxValidatorDirective;
    exports.MinValidatorDirective = MinValidatorDirective;
    exports.PasswordValidatorDirective = PasswordValidatorDirective;
    exports.PasswordValidators = PasswordValidators;
    exports.UniversalValidators = UniversalValidators;
    exports.ValidatorsModule = ValidatorsModule;
    exports.WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-validators.umd.js.map

import { __values, __decorate } from 'tslib';
import { Input, Directive, forwardRef, NgModule } from '@angular/core';
import { Validators, NG_VALIDATORS } from '@angular/forms';
import { delay } from 'rxjs/operators';

var AbstractControlUtil = /** @class */ (function () {
    function AbstractControlUtil() {
    }
    AbstractControlUtil.isNotPresent = function (control) {
        var value = control.value;
        if (value === undefined || value === null) {
            return true;
        }
        return value !== "" ? false : true;
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    AbstractControlUtil.addError = function (control, errorId, value) {
        var _a;
        if (!control.errors) {
            control.setErrors((_a = {}, _a[errorId] = value, _a));
        }
        else if (!control.hasError(errorId)) {
            control.errors[errorId] = value;
        }
    };
    AbstractControlUtil.removeError = function (control, errorId) {
        if (control.errors && control.hasError(errorId)) {
            if (Object.keys(control.errors).length > 1) {
                delete control.errors[errorId];
            }
            else {
                control.setErrors(null);
            }
        }
    };
    return AbstractControlUtil;
}());

// tslint:disable-next-line:variable-name
var PasswordValidators = /** @class */ (function () {
    function PasswordValidators() {
    }
    PasswordValidators.repeatCharacterRegexRule = function (repeatCount) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var repeatDec = repeatCount - 1;
            var pattern = "([^\\x00-\\x1F])\\1{" + repeatDec + "}";
            if (control.value !== "" && new RegExp(pattern).test(control.value)) {
                return { repeatCharacterRegexRule: { repeatCount: repeatCount } };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.allowedCharacterRule = function (allowedChars) {
        var validator = function (control) {
            var e_1, _a;
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            var valid = true;
            var invalidChars = [];
            try {
                for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                    var char = value_1_1.value;
                    if (allowedChars.indexOf(char) === -1) {
                        valid = false;
                        if (invalidChars.indexOf(char) === -1) {
                            invalidChars.push(char);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!valid) {
                return {
                    allowedCharacterRule: {
                        invalidChars: invalidChars,
                        allowedChars: allowedChars,
                    },
                };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.alphabeticalCharacterRule = function (amount) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            var pattern = /[^A-Za-z]+/g;
            var stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    alphabeticalCharacterRule: {
                        required: amount,
                        actual: stripped.length,
                    },
                };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.digitCharacterRule = function (amount) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            var pattern = /[^0-9\.]+/g;
            var stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    digitCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.lowercaseCharacterRule = function (amount) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            var pattern = /[^a-z]+/g;
            var stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    lowercaseCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.uppercaseCharacterRule = function (amount) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            var pattern = /[^A-Z]+/g;
            var stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    uppercaseCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.specialCharacterRule = function (amount) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            var pattern = /[\w\s]+/g;
            var stripped = value.replace(pattern, "");
            if (stripped.length < amount) {
                return {
                    specialCharacterRule: { required: amount, actual: stripped.length },
                };
            }
            return undefined;
        };
        return validator;
    };
    PasswordValidators.mismatchedPasswords = function (passwordControlName, confirmPasswordControlName) {
        var validator = function (group) {
            var newPasswordValue = group.get(passwordControlName ? passwordControlName : "newPassword").value;
            var newPasswordConfirmValue = group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword").value;
            if (newPasswordValue !== newPasswordConfirmValue) {
                AbstractControlUtil.addError(group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword"), "mismatchedPasswords", true);
                return { mismatchedPasswords: true };
            }
            else {
                AbstractControlUtil.removeError(group.get(confirmPasswordControlName ? confirmPasswordControlName : "confirmPassword"), "mismatchedPasswords");
            }
            return undefined;
        };
        return validator;
    };
    return PasswordValidators;
}());

/*
 * Code fromMailcheck https://github.com/mailcheck/mailcheck
 * Author
 * Derrick Ko (@derrickko)
 *
 * Released under the MIT License.
 *
 * v 1.1.2
 */
var EmailSuggestion = /** @class */ (function () {
    function EmailSuggestion() {
        this.defaultOptions = {
            domains: [
                "msn.com",
                "bellsouth.net",
                "telus.net",
                "comcast.net",
                "optusnet.com.au",
                "earthlink.net",
                "qq.com",
                "sky.com",
                "icloud.com",
                "mac.com",
                "sympatico.ca",
                "googlemail.com",
                "att.net",
                "xtra.co.nz",
                "web.de",
                "cox.net",
                "gmail.com",
                "ymail.com",
                "yahoo.com",
                "aim.com",
                "rogers.com",
                "verizon.net",
                "rocketmail.com",
                "google.com",
                "optonline.net",
                "sbcglobal.net",
                "aol.com",
                "me.com",
                "btinternet.com",
                "charter.net",
                "shaw.ca",
            ],
            secondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],
            topLevelDomains: [
                "com",
                "com.au",
                "com.tw",
                "ca",
                "co.nz",
                "co.uk",
                "de",
                "fr",
                "it",
                "ru",
                "net",
                "org",
                "edu",
                "gov",
                "jp",
                "nl",
                "kr",
                "se",
                "eu",
                "ie",
                "co.il",
                "us",
                "at",
                "be",
                "dk",
                "hk",
                "es",
                "gr",
                "ch",
                "no",
                "cz",
                "in",
                "net",
                "net.au",
                "info",
                "biz",
                "mil",
                "co.jp",
                "sg",
                "hu",
                "uk",
            ],
        };
    }
    EmailSuggestion.prototype.suggest = function (email, options) {
        var opt = this.defaultOptions;
        if (options !== undefined) {
            opt = options;
        }
        var emailParts = this.splitEmail(email.toLowerCase());
        if (!emailParts) {
            return undefined;
        }
        if (opt.secondLevelDomains && opt.topLevelDomains) {
            // If the email is a valid 2nd-level + top-level, do not suggest anything.
            if (opt.secondLevelDomains.indexOf(emailParts.secondLevelDomain) !== -1 &&
                opt.topLevelDomains.indexOf(emailParts.topLevelDomain) !== -1) {
                return undefined;
            }
        }
        var closestDomain = this.findClosestDomain(emailParts.domain, opt.domains, 2);
        if (closestDomain) {
            if (closestDomain === emailParts.domain) {
                // The email address exactly matches one of the supplied domains; do not return a suggestion.
                return undefined;
            }
            else {
                // The email address closely matches one of the supplied domains; return a suggestion
                return {
                    suggestion: {
                        address: emailParts.address,
                        domain: closestDomain,
                        full: emailParts.address + "@" + closestDomain,
                    },
                };
            }
        }
        var closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, opt.secondLevelDomains, 2);
        var closestTopLevelDomain = this.findClosestDomain(emailParts.topLevelDomain, opt.topLevelDomains, 2);
        if (emailParts.domain) {
            closestDomain = emailParts.domain;
            var rtrn = false;
            if (closestSecondLevelDomain && closestSecondLevelDomain !== emailParts.secondLevelDomain) {
                // The email address may have a mispelled second-level domain; return a suggestion
                closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain);
                rtrn = true;
            }
            if (closestTopLevelDomain &&
                closestTopLevelDomain !== emailParts.topLevelDomain &&
                emailParts.secondLevelDomain !== "") {
                // The email address may have a mispelled top-level domain; return a suggestion
                closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain);
                rtrn = true;
            }
            if (rtrn) {
                return {
                    suggestion: {
                        address: emailParts.address,
                        domain: closestDomain,
                        full: emailParts.address + "@" + closestDomain,
                    },
                };
            }
        }
        /* The email address exactly matches one of the supplied domains, does not closely
         * match any domain and does not appear to simply have a mispelled top-level domain,
         * or is an invalid email address; do not return a suggestion.
         */
        return undefined;
    };
    EmailSuggestion.prototype.splitEmail = function (email) {
        var parts = email.trim().split("@");
        if (parts.length < 2) {
            return undefined;
        }
        // tslint:disable-next-line: prefer-for-of
        for (var i = 0; i < parts.length; i++) {
            if (parts[i] === "") {
                return undefined;
            }
        }
        var result = {
            topLevelDomain: "",
            secondLevelDomain: "",
            domain: parts.pop(),
            address: "",
        };
        var domainParts = result.domain.split(".");
        if (domainParts.length === 0) {
            return undefined;
        }
        else if (domainParts.length === 1) {
            result.topLevelDomain = domainParts[0];
        }
        else {
            // The address has a domain and a top-level domain
            result.secondLevelDomain = domainParts[0];
            for (var j = 1; j < domainParts.length; j++) {
                result.topLevelDomain += domainParts[j] + ".";
            }
            result.topLevelDomain = result.topLevelDomain.substring(0, result.topLevelDomain.length - 1);
        }
        result.address = parts.join("@");
        return result;
    };
    EmailSuggestion.prototype.findClosestDomain = function (domain, domains, threshold) {
        var dist;
        var minDist = Infinity;
        var closestDomain = null;
        if (!domain || !domains) {
            return undefined;
        }
        // tslint:disable-next-line: prefer-for-of
        for (var i = 0; i < domains.length; i++) {
            if (domain === domains[i]) {
                return domain;
            }
            dist = this.sift4Distance(domain, domains[i], 5);
            if (dist < minDist) {
                minDist = dist;
                closestDomain = domains[i];
            }
        }
        if (minDist <= threshold && closestDomain !== null) {
            return closestDomain;
        }
        else {
            return undefined;
        }
    };
    EmailSuggestion.prototype.sift4Distance = function (s1, s2, maxOffset) {
        // sift4: https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
        if (maxOffset === undefined) {
            maxOffset = 5; // default
        }
        if (!s1 || !s1.length) {
            if (!s2) {
                return 0;
            }
            return s2.length;
        }
        if (!s2 || !s2.length) {
            return s1.length;
        }
        var l1 = s1.length;
        var l2 = s2.length;
        var c1 = 0; // cursor for string 1
        var c2 = 0; // cursor for string 2
        var lcss = 0; // largest common subsequence
        var localCS = 0; // local common substring
        var trans = 0; // number of transpositions ('ab' vs 'ba')
        var offsetArr = []; // offset pair array, for computing the transpositions
        while (c1 < l1 && c2 < l2) {
            if (s1.charAt(c1) === s2.charAt(c2)) {
                localCS++;
                var isTrans = false;
                // see if current match is a transposition
                var i = 0;
                while (i < offsetArr.length) {
                    var ofs = offsetArr[i];
                    if (c1 <= ofs.c1 || c2 <= ofs.c2) {
                        // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                        isTrans = Math.abs(c2 - c1) >= Math.abs(ofs.c2 - ofs.c1);
                        if (isTrans) {
                            trans++;
                        }
                        else {
                            if (!ofs.trans) {
                                ofs.trans = true;
                                trans++;
                            }
                        }
                        break;
                    }
                    else {
                        if (c1 > ofs.c2 && c2 > ofs.c1) {
                            offsetArr.splice(i, 1);
                        }
                        else {
                            i++;
                        }
                    }
                }
                offsetArr.push({
                    c1: c1,
                    c2: c2,
                    trans: isTrans,
                });
            }
            else {
                lcss += localCS;
                localCS = 0;
                if (c1 !== c2) {
                    c1 = c2 = Math.min(c1, c2); // using min allows the computation of transpositions
                }
                // if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
                // so that we can have only one code block handling matches
                for (var j = 0; j < maxOffset && (c1 + j < l1 || c2 + j < l2); j++) {
                    if (c1 + j < l1 && s1.charAt(c1 + j) === s2.charAt(c2)) {
                        c1 += j - 1;
                        c2--;
                        break;
                    }
                    if (c2 + j < l2 && s1.charAt(c1) === s2.charAt(c2 + j)) {
                        c1--;
                        c2 += j - 1;
                        break;
                    }
                }
            }
            c1++;
            c2++;
            // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
            if (c1 >= l1 || c2 >= l2) {
                lcss += localCS;
                localCS = 0;
                c1 = c2 = Math.min(c1, c2);
            }
        }
        lcss += localCS;
        return Math.round(Math.max(l1, l2) - lcss + trans); // add the cost of transpositions to the final result
    };
    return EmailSuggestion;
}());

var EmailValidators = /** @class */ (function () {
    function EmailValidators() {
    }
    EmailValidators.simple = function (control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        var pattern = /.+@.+\..+/i;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { simpleEmailRule: true };
    };
    // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    EmailValidators.normal = function (control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        // tslint:disable-next-line:max-line-length
        var pattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { normalEmailRule: true };
    };
    EmailValidators.suggest = function (options) {
        var _this = this;
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control)) {
                return undefined;
            }
            return _this.emailSuggestion.suggest(control.value, options);
        };
        return validator;
    };
    EmailValidators.emailSuggestion = new EmailSuggestion();
    return EmailValidators;
}());

var UniversalValidators = /** @class */ (function () {
    function UniversalValidators() {
    }
    UniversalValidators.noWhitespace = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        var pattern = "\\s";
        if (new RegExp(pattern).test(control.value)) {
            return { noWhitespaceRequired: true };
        }
        return undefined;
    };
    UniversalValidators.noEmptyString = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (control.value.trim().length === 0) {
            return { noEmptyString: true };
        }
        return undefined;
    };
    UniversalValidators.isNumber = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (isNaN(control.value)) {
            return { numberRequired: true };
        }
        return undefined;
    };
    UniversalValidators.isInRange = function (minValue, maxValue) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            if (+control.value < minValue) {
                return {
                    rangeValueToSmall: {
                        requiredMinValue: minValue,
                        requiredMaxValue: maxValue,
                        actual: control.value,
                    },
                };
            }
            if (+control.value > maxValue) {
                return {
                    rangeValueToBig: {
                        requiredMinValue: minValue,
                        requiredMaxValue: maxValue,
                        actual: control.value,
                    },
                };
            }
            else {
                return undefined;
            }
        };
        return validator;
    };
    UniversalValidators.minLength = function (minLength) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (value.length >= minLength) {
                return undefined;
            }
            return {
                minLength: { requiredMinLength: minLength, actualLength: value.length },
            };
        };
        return validator;
    };
    UniversalValidators.maxLength = function (maxLength) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (maxLength >= value.length) {
                return undefined;
            }
            return {
                maxLength: { requiredMaxLength: maxLength, actualLength: value.length },
            };
        };
        return validator;
    };
    UniversalValidators.min = function (min) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            if (+value >= min) {
                return undefined;
            }
            return { min: { required: min, actual: control.value } };
        };
        return validator;
    };
    UniversalValidators.max = function (max) {
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            var value = control.value;
            if (isNaN(control.value)) {
                return { numberRequired: true };
            }
            if (max >= +value) {
                return undefined;
            }
            return { max: { required: max, actual: control.value } };
        };
        return validator;
    };
    return UniversalValidators;
}());

var visaRegex = "^(?:4[0-9]{12})(?:[0-9]{3})?$";
var americanExpressRegex = "^(?:3[47][0-9]{13})$";
var maestroRegex = "^(?:(?:5[0678]\\d\\d|6304|6390|67\\d\\d)\\d{8,15})$";
var jcbRegex = "^(?:(?:2131|1800|35\\d{3})\\d{11})$";
var discoverRegex = "^(?:6(?:011|5[0-9]{2})(?:[0-9]{12}))$";
var dinersclubRegex = "^(?:3(?:0[0-5]|[68][0-9])[0-9]{11})$";
var mastercardRegex = "^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$";
var CreditCardValidators = /** @class */ (function () {
    function CreditCardValidators() {
    }
    CreditCardValidators.isCreditCard = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex +
            "|" +
            visaRegex +
            "|" +
            maestroRegex +
            "|" +
            jcbRegex +
            "|" +
            discoverRegex +
            "|" +
            mastercardRegex +
            "|" +
            dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { creditcard: true };
    };
    CreditCardValidators.americanExpress = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex).test(control.value)) {
            return undefined;
        }
        return { americanExpress: true };
    };
    CreditCardValidators.dinersclub = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { dinersclub: true };
    };
    CreditCardValidators.discover = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(discoverRegex).test(control.value)) {
            return undefined;
        }
        return { discover: true };
    };
    CreditCardValidators.jcb = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(jcbRegex).test(control.value)) {
            return undefined;
        }
        return { jcb: true };
    };
    CreditCardValidators.maestro = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(maestroRegex).test(control.value)) {
            return undefined;
        }
        return { maestro: true };
    };
    CreditCardValidators.mastercard = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(mastercardRegex).test(control.value)) {
            return undefined;
        }
        return { mastercard: true };
    };
    CreditCardValidators.visa = function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(visaRegex).test(control.value)) {
            return undefined;
        }
        return { visa: true };
    };
    return CreditCardValidators;
}());

var PasswordValidatorDirective = /** @class */ (function () {
    function PasswordValidatorDirective() {
        this.repeatCharacter = 4;
        this.alphabeticalCharacter = 1;
        this.digitCharacter = 1;
        this.lowercaseCharacter = 1;
        this.uppercaseCharacter = 1;
    }
    PasswordValidatorDirective_1 = PasswordValidatorDirective;
    PasswordValidatorDirective.prototype.ngOnInit = function () {
        this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(this.repeatCharacter);
        this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(this.alphabeticalCharacter);
        this.digitCharacterValidator = PasswordValidators.digitCharacterRule(this.digitCharacter);
        this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(this.lowercaseCharacter);
        this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(this.uppercaseCharacter);
    };
    PasswordValidatorDirective.prototype.ngOnChanges = function (changes) {
        var inputChanged = false;
        if (changes.repeatCharacter) {
            this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(changes.repeatCharacter.currentValue);
            inputChanged = changes.repeatCharacter.isFirstChange() ? false : true;
        }
        if (changes.alphabeticalCharacter) {
            this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(changes.alphabeticalCharacter.currentValue);
            inputChanged = changes.alphabeticalCharacter.isFirstChange() ? false : true;
        }
        if (changes.digitCharacter) {
            this.digitCharacterValidator = PasswordValidators.digitCharacterRule(changes.digitCharacter.currentValue);
            inputChanged = changes.digitCharacter.isFirstChange() ? false : true;
        }
        if (changes.lowercaseCharacter) {
            this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(changes.lowercaseCharacter.currentValue);
            inputChanged = changes.lowercaseCharacter.isFirstChange() ? false : true;
        }
        if (changes.uppercaseCharacter) {
            this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(changes.uppercaseCharacter.currentValue);
            inputChanged = changes.uppercaseCharacter.isFirstChange() ? false : true;
        }
        if (inputChanged) {
            this.onChange();
        }
    };
    PasswordValidatorDirective.prototype.validate = function (c) {
        var compose = Validators.compose([
            this.repeatCharacterValidator,
            this.digitCharacterValidator,
            this.alphabeticalCharacterValidator,
            this.lowercaseCharacterValidator,
            this.uppercaseCharacterValidator,
        ]);
        return compose(c);
    };
    PasswordValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var PasswordValidatorDirective_1;
    __decorate([
        Input()
    ], PasswordValidatorDirective.prototype, "repeatCharacter", void 0);
    __decorate([
        Input()
    ], PasswordValidatorDirective.prototype, "alphabeticalCharacter", void 0);
    __decorate([
        Input()
    ], PasswordValidatorDirective.prototype, "digitCharacter", void 0);
    __decorate([
        Input()
    ], PasswordValidatorDirective.prototype, "lowercaseCharacter", void 0);
    __decorate([
        Input()
    ], PasswordValidatorDirective.prototype, "uppercaseCharacter", void 0);
    PasswordValidatorDirective = PasswordValidatorDirective_1 = __decorate([
        Directive({
            selector: "[password][formControlName],[password][formControl],[password][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return PasswordValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], PasswordValidatorDirective);
    return PasswordValidatorDirective;
}());

var EmailValidatorDirective = /** @class */ (function () {
    function EmailValidatorDirective() {
        this.email = "normal";
    }
    EmailValidatorDirective_1 = EmailValidatorDirective;
    EmailValidatorDirective.prototype.ngOnInit = function () {
        this.setValidator(this.email);
    };
    EmailValidatorDirective.prototype.setValidator = function (type) {
        switch (type) {
            case "simple":
                this.validator = EmailValidators.simple;
                break;
            case "normal":
                this.validator = EmailValidators.normal;
                break;
            default:
                this.validator = EmailValidators.normal;
                break;
        }
    };
    EmailValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.email && !changes.email.isFirstChange()) {
            this.setValidator(changes.email.currentValue);
            this.onChange();
        }
    };
    EmailValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    EmailValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var EmailValidatorDirective_1;
    __decorate([
        Input()
    ], EmailValidatorDirective.prototype, "email", void 0);
    EmailValidatorDirective = EmailValidatorDirective_1 = __decorate([
        Directive({
            selector: "[email][formControlName],[email][formControl],[email][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EmailValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EmailValidatorDirective);
    return EmailValidatorDirective;
}());
var EmailSuggestValidatorDirective = /** @class */ (function () {
    function EmailSuggestValidatorDirective() {
    }
    EmailSuggestValidatorDirective_1 = EmailSuggestValidatorDirective;
    EmailSuggestValidatorDirective.prototype.ngOnInit = function () {
        this.validator = EmailValidators.suggest(this.emailSuggest);
    };
    EmailSuggestValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.emailSuggest && !changes.emailSuggest.isFirstChange()) {
            this.validator = EmailValidators.suggest(changes.emailSuggest.currentValue);
            this.onChange();
        }
    };
    EmailSuggestValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    EmailSuggestValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var EmailSuggestValidatorDirective_1;
    __decorate([
        Input()
    ], EmailSuggestValidatorDirective.prototype, "emailSuggest", void 0);
    EmailSuggestValidatorDirective = EmailSuggestValidatorDirective_1 = __decorate([
        Directive({
            selector: "[emailSuggest][formControlName],[emailSuggest][formControl],[emailSuggest][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EmailSuggestValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EmailSuggestValidatorDirective);
    return EmailSuggestValidatorDirective;
}());

var WhiteSpaceValidatorDirective = /** @class */ (function () {
    function WhiteSpaceValidatorDirective() {
    }
    WhiteSpaceValidatorDirective_1 = WhiteSpaceValidatorDirective;
    WhiteSpaceValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.noWhitespace;
    };
    WhiteSpaceValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var WhiteSpaceValidatorDirective_1;
    WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = __decorate([
        Directive({
            selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return WhiteSpaceValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], WhiteSpaceValidatorDirective);
    return WhiteSpaceValidatorDirective;
}());
var EmptyStringValidatorDirective = /** @class */ (function () {
    function EmptyStringValidatorDirective() {
    }
    EmptyStringValidatorDirective_1 = EmptyStringValidatorDirective;
    EmptyStringValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.noEmptyString;
    };
    EmptyStringValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var EmptyStringValidatorDirective_1;
    EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = __decorate([
        Directive({
            selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EmptyStringValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EmptyStringValidatorDirective);
    return EmptyStringValidatorDirective;
}());
var IsNumberValidatorDirective = /** @class */ (function () {
    function IsNumberValidatorDirective() {
    }
    IsNumberValidatorDirective_1 = IsNumberValidatorDirective;
    IsNumberValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.isNumber;
    };
    IsNumberValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var IsNumberValidatorDirective_1;
    IsNumberValidatorDirective = IsNumberValidatorDirective_1 = __decorate([
        Directive({
            selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return IsNumberValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], IsNumberValidatorDirective);
    return IsNumberValidatorDirective;
}());
var IsInRangeValidatorDirective = /** @class */ (function () {
    function IsInRangeValidatorDirective() {
    }
    IsInRangeValidatorDirective_1 = IsInRangeValidatorDirective;
    IsInRangeValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    };
    IsInRangeValidatorDirective.prototype.ngOnChanges = function (changes) {
        var minValue = this.minValue;
        var maxValue = this.maxValue;
        var changed = false;
        if (changes.minValue) {
            minValue = changes.minValue.currentValue;
            changed = changes.minValue.isFirstChange() ? false : true;
        }
        if (changes.maxValue) {
            maxValue = changes.maxValue.currentValue;
            changed = changes.maxValue.isFirstChange() ? false : true;
        }
        if (changed) {
            this.validator = UniversalValidators.isInRange(minValue, maxValue);
            this.onChange();
        }
    };
    IsInRangeValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    IsInRangeValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var IsInRangeValidatorDirective_1;
    __decorate([
        Input()
    ], IsInRangeValidatorDirective.prototype, "minValue", void 0);
    __decorate([
        Input()
    ], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
    IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = __decorate([
        Directive({
            selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return IsInRangeValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], IsInRangeValidatorDirective);
    return IsInRangeValidatorDirective;
}());
var MaxValidatorDirective = /** @class */ (function () {
    function MaxValidatorDirective() {
    }
    MaxValidatorDirective_1 = MaxValidatorDirective;
    MaxValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.max(this.max);
    };
    MaxValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.max && !changes.max.isFirstChange()) {
            this.validator = UniversalValidators.max(changes.max.currentValue);
            this.onChange();
        }
    };
    MaxValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MaxValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MaxValidatorDirective_1;
    __decorate([
        Input()
    ], MaxValidatorDirective.prototype, "max", void 0);
    MaxValidatorDirective = MaxValidatorDirective_1 = __decorate([
        Directive({
            selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MaxValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MaxValidatorDirective);
    return MaxValidatorDirective;
}());
var MinValidatorDirective = /** @class */ (function () {
    function MinValidatorDirective() {
    }
    MinValidatorDirective_1 = MinValidatorDirective;
    MinValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.min(this.min);
    };
    MinValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.min && !changes.min.isFirstChange()) {
            this.validator = UniversalValidators.min(changes.min.currentValue);
            this.onChange();
        }
    };
    MinValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MinValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MinValidatorDirective_1;
    __decorate([
        Input()
    ], MinValidatorDirective.prototype, "min", void 0);
    MinValidatorDirective = MinValidatorDirective_1 = __decorate([
        Directive({
            selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MinValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MinValidatorDirective);
    return MinValidatorDirective;
}());

var CreditCardValidatorDirective = /** @class */ (function () {
    function CreditCardValidatorDirective() {
        this.creditCard = "all";
    }
    CreditCardValidatorDirective_1 = CreditCardValidatorDirective;
    CreditCardValidatorDirective.prototype.ngOnInit = function () {
        this.setCreditcardValidator(this.creditCard);
    };
    CreditCardValidatorDirective.prototype.setCreditcardValidator = function (type) {
        switch (type) {
            case "all":
                this.validator = CreditCardValidators.isCreditCard;
                break;
            case "americanExpress":
                this.validator = CreditCardValidators.americanExpress;
                break;
            case "dinersclub":
                this.validator = CreditCardValidators.dinersclub;
                break;
            case "discover":
                this.validator = CreditCardValidators.discover;
                break;
            case "jcb":
                this.validator = CreditCardValidators.jcb;
                break;
            case "maestro":
                this.validator = CreditCardValidators.maestro;
                break;
            case "mastercard":
                this.validator = CreditCardValidators.mastercard;
                break;
            case "visa":
                this.validator = CreditCardValidators.visa;
                break;
            default:
                this.validator = CreditCardValidators.isCreditCard;
                break;
        }
    };
    CreditCardValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.creditCard && !changes.creditCard.isFirstChange()) {
            this.setCreditcardValidator(changes.creditCard.currentValue);
            this.onChange();
        }
    };
    CreditCardValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    CreditCardValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var CreditCardValidatorDirective_1;
    __decorate([
        Input()
    ], CreditCardValidatorDirective.prototype, "creditCard", void 0);
    CreditCardValidatorDirective = CreditCardValidatorDirective_1 = __decorate([
        Directive({
            selector: "[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    useExisting: forwardRef(function () { return CreditCardValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], CreditCardValidatorDirective);
    return CreditCardValidatorDirective;
}());

var EqualToDirective = /** @class */ (function () {
    function EqualToDirective() {
    }
    EqualToDirective_1 = EqualToDirective;
    EqualToDirective.prototype.validate = function (c) {
        var otherControl = typeof this.equalTo === "string" ? c.parent.get(this.equalTo) : this.equalTo;
        if (!this.subscription) {
            this.subscription = otherControl.valueChanges.pipe(delay(1)).subscribe(function () {
                c.updateValueAndValidity();
            });
        }
        return c.value !== otherControl.value ? { notEqualTo: true } : null;
    };
    EqualToDirective.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    EqualToDirective.prototype.ngOnChanges = function (changes) {
        if (changes.equalTo && !changes.equalTo.isFirstChange()) {
            this.onChange();
        }
    };
    EqualToDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var EqualToDirective_1;
    __decorate([
        Input()
    ], EqualToDirective.prototype, "equalTo", void 0);
    EqualToDirective = EqualToDirective_1 = __decorate([
        Directive({
            selector: "[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EqualToDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EqualToDirective);
    return EqualToDirective;
}());

var ValidatorsModule = /** @class */ (function () {
    function ValidatorsModule() {
    }
    ValidatorsModule = __decorate([
        NgModule({
            declarations: [
                CreditCardValidatorDirective,
                EmailValidatorDirective,
                EmailSuggestValidatorDirective,
                PasswordValidatorDirective,
                IsInRangeValidatorDirective,
                IsNumberValidatorDirective,
                MaxValidatorDirective,
                MinValidatorDirective,
                WhiteSpaceValidatorDirective,
                EmptyStringValidatorDirective,
                EqualToDirective,
            ],
            exports: [
                CreditCardValidatorDirective,
                EmailValidatorDirective,
                EmailSuggestValidatorDirective,
                PasswordValidatorDirective,
                IsInRangeValidatorDirective,
                IsNumberValidatorDirective,
                MaxValidatorDirective,
                MinValidatorDirective,
                WhiteSpaceValidatorDirective,
                EmptyStringValidatorDirective,
                EqualToDirective,
            ],
        })
    ], ValidatorsModule);
    return ValidatorsModule;
}());

var EqualToValidator = /** @class */ (function () {
    function EqualToValidator() {
    }
    EqualToValidator.equalTo = function (c1Name, c2Name) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var validator = function (parent) {
            var c1 = parent.get(c1Name);
            var c2 = parent.get(c2Name);
            if (c1.value === c2.value) {
                AbstractControlUtil.removeError(c2, "notEqualTo");
            }
            else {
                AbstractControlUtil.addError(c2, "notEqualTo", true);
            }
        };
        return validator;
    };
    return EqualToValidator;
}());

// validators

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractControlUtil, CreditCardValidatorDirective, CreditCardValidators, EmailSuggestValidatorDirective, EmailSuggestion, EmailValidatorDirective, EmailValidators, EmptyStringValidatorDirective, EqualToDirective, EqualToValidator, IsInRangeValidatorDirective, IsNumberValidatorDirective, MaxValidatorDirective, MinValidatorDirective, PasswordValidatorDirective, PasswordValidators, UniversalValidators, ValidatorsModule, WhiteSpaceValidatorDirective };
//# sourceMappingURL=ngx-validators.js.map

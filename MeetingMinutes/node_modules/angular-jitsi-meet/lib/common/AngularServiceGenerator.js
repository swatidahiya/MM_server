// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var AngularServiceGenerator,
    slice = [].slice;

  AngularServiceGenerator = {

    /*
      Creates an angular service which wraps module and wires up events from options.eventMaps. It also creates
      angular constants for each list of events.
      * Assumes that options.eventMaps is an object with keys being the angular constant name and value being an object of
      key value pairs of events.  See eventMappings.coffee for an example
    
      @input moduleObject
      @input moduleName
      @input options - an object with eventMaps, and flipAddListenerArgs properties. All are optional
      @returns angularModuleName
     */
    wrapInAngular: function(angularModule, moduleObject, serviceName) {
      if (!moduleObject || !serviceName) {
        throw Error('moduleObject and serviceName are required parameters');
      }
      console.debug("Creating angular service " + serviceName + " in " + angularModule.name);
      angularModule.factory(serviceName, [
        function() {
          return moduleObject;
        }
      ]);
      return angularModule;
    },
    makeEventConstants: function(angularModule, eventMapping) {
      var eventMap, eventMapName, ref, results;
      ref = eventMapping.eventMaps;
      results = [];
      for (eventMapName in ref) {
        eventMap = ref[eventMapName];
        console.debug("Creating angular constant " + eventMapName + " in " + angularModule.name);
        results.push(angularModule.constant(eventMapName, eventMap));
      }
      return results;
    },
    wireUpEvents: function(EventAdapter, angularModule, moduleObject, eventMapping) {
      var eventMap, eventMapName, events, ref;
      events = [];
      ref = eventMapping != null ? eventMapping.eventMaps : void 0;
      for (eventMapName in ref) {
        eventMap = ref[eventMapName];
        events.push(eventMap);
      }
      if (!(eventMapping != null ? eventMapping.callbacks : void 0)) {
        eventMapping.callbacks = [];
      }
      if (eventMapping.flipAddListenerArgs) {
        return eventMapping.callbacks.push(EventAdapter.wireUpEventsReverse.apply(EventAdapter, [moduleObject].concat(slice.call(events))));
      } else {
        return eventMapping.callbacks.push(EventAdapter.wireUpEvents.apply(EventAdapter, [moduleObject].concat(slice.call(events))));
      }
    },
    clearEvents: function(EventAdapter, eventMapping, moduleObject) {
      var callback, i, len, ref, results;
      if (eventMapping != null ? eventMapping.callbacks : void 0) {
        ref = eventMapping.callbacks;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          callback = ref[i];
          results.push(EventAdapter.clearEvents(moduleObject, callback));
        }
        return results;
      }
    }
  };

  module.exports = AngularServiceGenerator;

}).call(this);
